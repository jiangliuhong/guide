---
title: 设计模式-总览
categories: 
    - 设计模式
date: 2018-07-14 20:52:08
tags:
    - Java
    - 设计模式
---
# 设计模式-总览

> 设计模式（Design pattern）是一种被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。即：在某些场景下，针对某类问题的某种通用的解决办法

## 设计模式分类

- **创建型模式**：对象实例化的模式，创建型模式用于解耦对象的实例化过程

- **结构型模式**： 把类或对象结合在一起形成一个更大的结构

- **行为型模式** ：类和对象如何交互，及划分责任和算法

  ![设计模式](https://static.jiangliuhong.top/blogimg/java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%86%E7%B1%BB.png)

### 创建型设计模式

> 创建型模式(Creational Pattern)对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离。为了使软件的结构更加清晰，外界对于这些对象只需要知道它们共同的接口，而不清楚其具体的实现细节，使整个系统的设计更加符合单一职责原则 。
>
> 创建型模式隐藏了类的实例的创建细节，通过隐藏对象如何被创建和组合在一起达到使整个系统独立的目的。

| 名称                           | 重要程度 | 说明                                                         | 链接                                                         |
| ------------------------------ | -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 工厂模式(Factory)              | ★★★★★    | 定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行 。 | [工厂模式](/2020/04/19/Java/设计模式/设计模式-工厂模式/) |
| 抽象工厂模式(Abstract Factory) | ★★       | 提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类 | [工厂模式](/2020/04/19/Java/设计模式/设计模式-工厂模式/) |
| 建造者模式(Builder)            | ★★★      | 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示 | [建造者模式](/2020/04/21/Java/设计模式/设计模式-建造者模式/) |
| 原型模式(Prototype)            | ★★★      | 用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。 |                                                              [原型模式](/2020/04/21/Java/设计模式/设计模式-原型模式/)|
| 单例模式(Singleton)            | ★★★★     | 在整个应用中保证只有一个类的实例存在。                       | [单例模式](/2020/04/21/Java/设计模式/设计模式-单例模式/) |

### 结构型设计模式

| 名称                  | 重要程度 | 说明                                                         | 链接                                                         |
| --------------------- | -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 适配器模式( Adapter ) | ★★★★     | 定义一个包装类，用于包装不兼容接口的对象                     |                                                              |
| 桥接模式( Bridge )    | ★★★      | 将抽象部分与它的实现部分分离，使它们都可以独立地变化         |                                                              |
| 组合模式( Composite ) | ★★★★     | 将对象组合成树形结构以表示“部分-整体”的层次结构。Composite使得用户对单个对象和组合对象的使用具有一致性 |                                                              |
| 装饰模式( Decorator ) | ★★★      | 动态地给一个对象增加一些额外的职责(Responsibility)，就增加对象功能来说，装饰模式比生成子类实现更为灵活 |                                                              |
| 外观模式( Facade )    | ★★★★★    | 外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用 | [外观模式](https://blog.csdn.net/jlh912008548/article/details/81054502) |
| 亨元模式( Flyweight ) | ★        | 运用共享技术有效地支持大量细粒度对象的复用                   |                                                              |
| 代理模式( Proxy )     | ★★★★     | 给某一个对象提供一个代 理，并由代理对象控制对原对象的引用    |                                                              |

### 行为型设计模式

> 行为型模式(Behavioral Pattern)是对在不同的对象之间划分责任和算法的抽象化 。
>
> 行为型模式不仅仅关注类和对象的结构，而且重点关注它们之间的相互作用。 
>
> 通过行为型模式，可以更加清晰地划分类与对象的职责，并研究系统在运行时实例对象 之间的交互。在系统运行时，对象并不是孤立的，它们可以通过相互通信与协作完成某些复杂功能，一个对象在运行时也将影响到其他对象的运行。 
>

行为型模式主要分为以下两种：

- 类行为型模式 ：类的行为型模式使用继承关系在几个类之间分配行为，类行为型模式主要通过多态等方式来分配父类与子类的职责
- 对象行为型模式：对象的行为型模式则使用对象的聚合关联关系来分配行为，对象行为型模式主要是通过对象关联等方式来分配两个或多个类的职责。根据“合成复用原则”，系统中要尽量使用关联关系来取代继承关系，因此大部分行为型设计模式都属于对象行为型设计模式

| 名称                                  | 重要程度 | 说明                                                         | 链接                                                         |
| ------------------------------------- | -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 责任链模式( Chain of Responsibility ) | ★★★      | 为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦 |                                                              |
| 命令模式( Command )                   | ★★★★     | 将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作 |                                                              |
| 解释器模式( Interpreter )             | ★        |                                                              |                                                              |
| 迭代器模式( Iterator )                | ★★★★★    | 提供一种方法访问一个容器对象中各个元素，而又不暴露该对象的内部细节 |                                                              |
| 中介者模式( Mediator )                | ★★       | 用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互 |                                                              |
| 备忘录模式( Memento )                 | ★★       | 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态 |                                                              |
| 观察者模式( Observer )                | ★★★★★    | 定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新 | [观察者模式](https://blog.csdn.net/jlh912008548/article/details/81054547) |
| 状态模式( State )                     | ★★★      | 允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类 |                                                              |
| 策略模式( Strategy )                  | ★★★★     | 定义一系列算法，将每一个算法封装起来，并让它们可以相互替换   |                                                              |
| 模板方法模式( Template Method) )      | ★★★      | 使得子类可以在不改变算法结构的情况下，重新定义算法中的某一些步骤 |                                                              |
| 访问者模式( Visitor )                 | ★        | 提供一个作用于某对象结构中的各元素的操作表示，它使我们可以在不改变各元素的类的前提下定义作用于这些元素的新操作 |                                                              |

------

**参考资料**

[http://design-patterns.readthedocs.io/zh_CN/latest/](http://design-patterns.readthedocs.io/zh_CN/latest/)
