<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="
  数据存储
  #

以InnoDB为例，InnoDB 是将数据存储在磁盘中，需要处理数据时，再将数据读取到内存中进行处理，对于 InnoDB 引擎会将数据划分为若干页，以页做为磁盘和内存交互的基本单位。InnoDB中页的大小一般为16KB。
在MySQL服务运行的过程中不可以修改页的大小，只能在初始化数据目录的时候指定。

  存储的文件
  #

假设目前存在一个数据库为testdb，在数据库中存在一个表为user，那么在MySQL 的数据目录/var/lib/mysql下将会存在这样的目录
|-- testdb
	|-- db.opt  
  |-- user.frm  
  |-- user.ibd

db.opt，用来存储当前数据库的默认字符集和字符校验规则。
t_order.frm ，t_order 的表结构会保存在这个文件。在 MySQL 中建立一张表都会生成一个.frm 文件，该文件是用来保存每个表的元数据信息的，主要包含表结构定义。
t_order.ibd，t_order 的表数据会保存在这个文件。表数据既可以存在共享表空间文件（文件名：ibdata1）里，也可以存放在独占表空间文件（文件名：表名字.idb）。这个行为是由参数 innodb_file_per_table 控制的，若设置了参数 innodb_file_per_table 为 1，则会将存储的数据、索引等信息单独存储在一个独占表空间，从 MySQL 5.6.6 版本开始，它的默认值就是 1 了，因此从这个版本之后， MySQL 中每一张表的数据都存放在一个独立的 .idb 文件。


  存储文件结构
  #

表空间由段（segment）、区（extent）、页（page）、行（row）组成，InnoDB存储引擎的逻辑存储结构大致如图：

行：数据库表中的记录都是按行（row）进行存放的，每行记录根据不同的行格式，有不同的存储结构。
页：


记录是按照行来存储的，但是数据库的读取并不以「行」为单位，否则一次读取（也就是一次 I/O 操作）只能处理一行数据，效率会非常低。


InnoDB 的数据是按「页」为单位来读写的，也就是说，当需要读一条记录的时候，并不是将这个行记录从磁盘读出来，而是以页为单位，将其整体读入内存。


默认每个页的大小为 16KB，也就是最多能保证 16KB 的连续存储空间。


区：
B&#43; 树中每一层都是通过双向链表连接起来的，如果是以页为单位来分配存储空间，那么链表中相邻的两个页之间的物理位置并不是连续的，可能离得非常远，那么磁盘查询时就会有大量的随机I/O，随机 I/O 是非常慢的。
解决办法就是让链表中相邻的页的物理位置也相邻，这样就可以使用顺序 I/O 了，那么在范围查询（扫描叶子节点）的时候性能就会很高。
在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区（extent）为单位分配。每个区的大小为 1MB，对于 16KB 的页来说，连续的 64 个页会被划为一个区，这样就使得链表中相邻的页的物理位置也相邻，就能使用顺序 I/O 了。">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:url" content="http://localhost:1313/docs/database/mysql/storage/">
  <meta property="og:site_name" content="复习吧">
  <meta property="og:title" content="数据存储">
  <meta property="og:description" content="数据存储 # 以InnoDB为例，InnoDB 是将数据存储在磁盘中，需要处理数据时，再将数据读取到内存中进行处理，对于 InnoDB 引擎会将数据划分为若干页，以页做为磁盘和内存交互的基本单位。InnoDB中页的大小一般为16KB。
在MySQL服务运行的过程中不可以修改页的大小，只能在初始化数据目录的时候指定。
存储的文件 # 假设目前存在一个数据库为testdb，在数据库中存在一个表为user，那么在MySQL 的数据目录/var/lib/mysql下将会存在这样的目录
|-- testdb |-- db.opt |-- user.frm |-- user.ibd db.opt，用来存储当前数据库的默认字符集和字符校验规则。 t_order.frm ，t_order 的表结构会保存在这个文件。在 MySQL 中建立一张表都会生成一个.frm 文件，该文件是用来保存每个表的元数据信息的，主要包含表结构定义。 t_order.ibd，t_order 的表数据会保存在这个文件。表数据既可以存在共享表空间文件（文件名：ibdata1）里，也可以存放在独占表空间文件（文件名：表名字.idb）。这个行为是由参数 innodb_file_per_table 控制的，若设置了参数 innodb_file_per_table 为 1，则会将存储的数据、索引等信息单独存储在一个独占表空间，从 MySQL 5.6.6 版本开始，它的默认值就是 1 了，因此从这个版本之后， MySQL 中每一张表的数据都存放在一个独立的 .idb 文件。 存储文件结构 # 表空间由段（segment）、区（extent）、页（page）、行（row）组成，InnoDB存储引擎的逻辑存储结构大致如图：
行：数据库表中的记录都是按行（row）进行存放的，每行记录根据不同的行格式，有不同的存储结构。
页：
记录是按照行来存储的，但是数据库的读取并不以「行」为单位，否则一次读取（也就是一次 I/O 操作）只能处理一行数据，效率会非常低。
InnoDB 的数据是按「页」为单位来读写的，也就是说，当需要读一条记录的时候，并不是将这个行记录从磁盘读出来，而是以页为单位，将其整体读入内存。
默认每个页的大小为 16KB，也就是最多能保证 16KB 的连续存储空间。
区：
B&#43; 树中每一层都是通过双向链表连接起来的，如果是以页为单位来分配存储空间，那么链表中相邻的两个页之间的物理位置并不是连续的，可能离得非常远，那么磁盘查询时就会有大量的随机I/O，随机 I/O 是非常慢的。
解决办法就是让链表中相邻的页的物理位置也相邻，这样就可以使用顺序 I/O 了，那么在范围查询（扫描叶子节点）的时候性能就会很高。
在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区（extent）为单位分配。每个区的大小为 1MB，对于 16KB 的页来说，连续的 64 个页会被划为一个区，这样就使得链表中相邻的页的物理位置也相邻，就能使用顺序 I/O 了。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="docs">
    <meta property="article:published_time" content="2024-01-14T11:53:59+08:00">
    <meta property="article:modified_time" content="2024-01-17T11:06:23+08:00">
<title>数据存储 | 复习吧</title>
<link rel="manifest" href="/manifest.json">
<link rel="icon" href="/favicon.png" >
<link rel="stylesheet" href="/book.min.cdf2dd29f013b9b416743e9529e3db831a1462598e2803454998241de8e37466.css" integrity="sha256-zfLdKfATubQWdD6VKePbgxoUYlmOKANFSZgkHejjdGY=" crossorigin="anonymous">
  <script defer src="/flexsearch.min.js"></script>
  <script defer src="/en.search.min.80ca7f71d8159d5795f243152f289067a8e79866a78fb2aad41736a324b0b3da.js" integrity="sha256-gMp/cdgVnVeV8kMVLyiQZ6jnmGanj7Kq1Bc2oySws9o=" crossorigin="anonymous"></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><span>复习吧</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>












  <ul>
<li>数据库
<ul>
<li><a href="/docs/database/mysql/">MySQL</a>
<ul>
<li><a href="/docs/database/mysql/indexes/">索引</a></li>
<li><a href="/docs/database/mysql/trans/">事务</a></li>
<li><a href="/docs/database/mysql/storage/"class=active>数据存储</a></li>
<li><a href="/docs/database/mysql/cluster/">集群</a></li>
<li><a href="/docs/database/mysql/normal/">常见面试题</a></li>
</ul>
</li>
<li>NOSQL 数据库
<ul>
<li><a href="/docs/database/redis/">Redis</a>
<ul>
<li><a href="/docs/database/redis/base/">基础概念</a></li>
<li><a href="/docs/database/redis/data/">数据结构</a></li>
<li><a href="/docs/database/redis/high/">高可用</a></li>
<li><a href="/docs/database/redis/apply/">应用实践</a></li>
</ul>
</li>
<li><a href="/docs/database/es/">ElastiSearch</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="/docs/java/">Java</a></li>
<li>算法
<ul>
<li><a href="/docs/arithmetic/data/">数据结构</a></li>
</ul>
</li>
<li>中间件
<ul>
<li><a href="/docs/middleware/messagequeue/">消息队列</a></li>
</ul>
</li>
</ul>










</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>数据存储</strong>

  <label for="toc-control">
    
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#存储的文件">存储的文件</a></li>
    <li><a href="#存储文件结构">存储文件结构</a></li>
    <li><a href="#innodb-行格式">InnoDB 行格式</a>
      <ul>
        <li><a href="#记录的额外信息">记录的额外信息</a></li>
        <li><a href="#变长字段长度列表">变长字段长度列表</a></li>
        <li><a href="#为什么逆序存放">为什么逆序存放</a></li>
        <li><a href="#记录头信息">记录头信息</a></li>
        <li><a href="#null-值列表">NULL 值列表</a></li>
        <li><a href="#记录的真实数据">记录的真实数据</a></li>
        <li><a href="#行溢出处理">行溢出处理</a></li>
      </ul>
    </li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown"><h1 id="数据存储">
  数据存储
  <a class="anchor" href="#%e6%95%b0%e6%8d%ae%e5%ad%98%e5%82%a8">#</a>
</h1>
<p>以InnoDB为例，InnoDB 是将数据存储在磁盘中，需要处理数据时，再将数据读取到内存中进行处理，对于 InnoDB 引擎会将数据划分为若干页，以页做为磁盘和内存交互的基本单位。InnoDB中页的大小一般为16KB。</p>
<p>在MySQL服务运行的过程中不可以修改页的大小，只能在初始化数据目录的时候指定。</p>
<h2 id="存储的文件">
  存储的文件
  <a class="anchor" href="#%e5%ad%98%e5%82%a8%e7%9a%84%e6%96%87%e4%bb%b6">#</a>
</h2>
<p>假设目前存在一个数据库为<code>testdb</code>，在数据库中存在一个表为<code>user</code>，那么在MySQL 的数据目录<code>/var/lib/mysql</code>下将会存在这样的目录</p>
<pre tabindex="0"><code>|-- testdb
	|-- db.opt  
  |-- user.frm  
  |-- user.ibd
</code></pre><ul>
<li>db.opt，用来存储当前数据库的默认字符集和字符校验规则。</li>
<li>t_order.frm ，t_order 的<strong>表结构</strong>会保存在这个文件。在 MySQL 中建立一张表都会生成一个.frm 文件，该文件是用来保存每个表的元数据信息的，主要包含表结构定义。</li>
<li>t_order.ibd，t_order 的<strong>表数据</strong>会保存在这个文件。表数据既可以存在共享表空间文件（文件名：ibdata1）里，也可以存放在独占表空间文件（文件名：表名字.idb）。这个行为是由参数 innodb_file_per_table 控制的，若设置了参数 innodb_file_per_table 为 1，则会将存储的数据、索引等信息单独存储在一个独占表空间，从 MySQL 5.6.6 版本开始，它的默认值就是 1 了，因此从这个版本之后， MySQL 中每一张表的数据都存放在一个独立的 .idb 文件。</li>
</ul>
<h2 id="存储文件结构">
  存储文件结构
  <a class="anchor" href="#%e5%ad%98%e5%82%a8%e6%96%87%e4%bb%b6%e7%bb%93%e6%9e%84">#</a>
</h2>
<p><strong>表空间由段（segment）、区（extent）、页（page）、行（row）组成</strong>，InnoDB存储引擎的逻辑存储结构大致如图：</p>
<p><img src="https://static.jiangliuhong.top/images/2024/1/tablespacestruct.png" alt="表空间结构" /></p>
<p>行：数据库表中的记录都是按行（row）进行存放的，每行记录根据不同的行格式，有不同的存储结构。</p>
<p>页：</p>
<ul>
<li>
<p>记录是按照行来存储的，但是数据库的读取并不以「行」为单位，否则一次读取（也就是一次 I/O 操作）只能处理一行数据，效率会非常低。</p>
</li>
<li>
<p><strong>InnoDB 的数据是按「页」为单位来读写的</strong>，也就是说，当需要读一条记录的时候，并不是将这个行记录从磁盘读出来，而是以页为单位，将其整体读入内存。</p>
</li>
<li>
<p><strong>默认每个页的大小为 16KB</strong>，也就是最多能保证 16KB 的连续存储空间。</p>
</li>
</ul>
<p>区：</p>
<p>B+ 树中每一层都是通过双向链表连接起来的，如果是以页为单位来分配存储空间，那么链表中相邻的两个页之间的物理位置并不是连续的，可能离得非常远，那么磁盘查询时就会有大量的随机I/O，随机 I/O 是非常慢的。</p>
<p>解决办法就是让链表中相邻的页的物理位置也相邻，这样就可以使用顺序 I/O 了，那么在范围查询（扫描叶子节点）的时候性能就会很高。</p>
<p>在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区（extent）为单位分配。每个区的大小为 1MB，对于 16KB 的页来说，连续的 64 个页会被划为一个区，这样就使得链表中相邻的页的物理位置也相邻，就能使用顺序 I/O 了。</p>
<p>段：表空间是由各个段（segment）组成的，段是由多个区（extent）组成的。段一般分为数据段、索引段和回滚段等。</p>
<ul>
<li>索引段：存放 B + 树的非叶子节点的区的集合；</li>
<li>数据段：存放 B + 树的叶子节点的区的集合；</li>
<li>回滚段：存放的是回滚数据的区的集合</li>
</ul>
<h2 id="innodb-行格式">
  InnoDB 行格式
  <a class="anchor" href="#innodb-%e8%a1%8c%e6%a0%bc%e5%bc%8f">#</a>
</h2>
<p>行格式（row_format）：一条数据记录在磁盘上的存储结构。</p>
<p>InnoDB 提供了 4 种行格式，分别是 Redundant、Compact、Dynamic和 Compressed 行格式。</p>
<p>我们可以在创建表或者修改表的语句中指定所使用的行格式</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">table</span> <span style="color:#e6db74">&#39;table info ..&#39;</span> row_format <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;行格式名称&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">alter</span> <span style="color:#66d9ef">table</span> <span style="color:#e6db74">&#39;table name&#39;</span> row_format <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;行格式名称&#39;</span>
</span></span></code></pre></div><p>InnoDB 提供了 4 种行格式，分别是 Redundant、Compact、Dynamic和 Compressed 行格式：</p>
<ol>
<li><strong>Compact（默认）：</strong> COMPACT是MySQL的默认行格式，它对于读密集型的工作负载通常表现良好。它采用变长的存储方式，并且对于短字段使用前缀压缩。</li>
<li><strong>Redundant：</strong> REDUNDANT行格式使用了更多的存储空间，但在某些特殊情况下可能提供更好的性能。它通常用于处理特定的事务性工作负载。</li>
<li><strong>Dynamic：</strong> DYNAMIC行格式采用变长字段，但相较于COMPACT，它对于短字段的压缩更为灵活，因此在某些情况下可能会更加节省空间。</li>
<li><strong>Compressed：</strong> BARRACUDA是一种文件格式，而不是行格式。在MySQL 5.6之后的版本，InnoDB引擎引入了支持动态格式的文件格式BARRACUDA。</li>
</ol>
<p>其中Compressed与Redundant存储格式与Compact相似；Redundant是一种古老的格式，如今使用微乎其微。</p>
<p>Compact格式主要分为两部分：记录额外信息、记录的真是数据，如图：</p>
<p><img src="https://static.jiangliuhong.top/images/2024/1/15mysql_compact.png" alt="15mysql_compact.png" /></p>
<h3 id="记录的额外信息">
  记录的额外信息
  <a class="anchor" href="#%e8%ae%b0%e5%bd%95%e7%9a%84%e9%a2%9d%e5%a4%96%e4%bf%a1%e6%81%af">#</a>
</h3>
<p>记录的额外信息包含 3 个部分：变长字段长度列表、NULL 值列表、记录头信息。</p>
<h3 id="变长字段长度列表">
  变长字段长度列表
  <a class="anchor" href="#%e5%8f%98%e9%95%bf%e5%ad%97%e6%ae%b5%e9%95%bf%e5%ba%a6%e5%88%97%e8%a1%a8">#</a>
</h3>
<p>在存储数据的时候，需要要把数据占用的大小存起来，存到「变长字段长度列表」里面，读取数据的时候才能根据这个「变长字段长度列表」去读取对应长度的数据。VARCHAR、TEXT、BLOB 等变长字段都是这样实现的。</p>
<p>首先创建一个表<code>t_user</code>并插入数据</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">TABLE</span> <span style="color:#f92672">`</span>t_user<span style="color:#f92672">`</span> (
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">`</span>id<span style="color:#f92672">`</span> int(<span style="color:#ae81ff">11</span>) <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">`</span>name<span style="color:#f92672">`</span> VARCHAR(<span style="color:#ae81ff">20</span>) <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">`</span>phone<span style="color:#f92672">`</span> VARCHAR(<span style="color:#ae81ff">20</span>) <span style="color:#66d9ef">DEFAULT</span> <span style="color:#66d9ef">NULL</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">`</span>age<span style="color:#f92672">`</span> int(<span style="color:#ae81ff">11</span>) <span style="color:#66d9ef">DEFAULT</span> <span style="color:#66d9ef">NULL</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">PRIMARY</span> <span style="color:#66d9ef">KEY</span> (<span style="color:#f92672">`</span>id<span style="color:#f92672">`</span>) <span style="color:#66d9ef">USING</span> BTREE
</span></span><span style="display:flex;"><span>) ENGINE <span style="color:#f92672">=</span> InnoDB <span style="color:#66d9ef">DEFAULT</span> CHARACTER <span style="color:#66d9ef">SET</span> <span style="color:#f92672">=</span> ascii ROW_FORMAT <span style="color:#f92672">=</span> COMPACT;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t_user  <span style="color:#66d9ef">values</span> (<span style="color:#ae81ff">1</span>,<span style="color:#e6db74">&#39;a&#39;</span>,<span style="color:#e6db74">&#39;123&#39;</span>,<span style="color:#ae81ff">18</span>),(<span style="color:#ae81ff">2</span>,<span style="color:#e6db74">&#39;bb&#39;</span>,<span style="color:#e6db74">&#39;1234&#39;</span>,<span style="color:#66d9ef">null</span>),(<span style="color:#ae81ff">3</span>,<span style="color:#e6db74">&#39;ccc&#39;</span>,<span style="color:#66d9ef">null</span>,<span style="color:#66d9ef">null</span>)
</span></span></code></pre></div><p>现在t_user表的数据为：</p>
<pre tabindex="0"><code>id|name|phone|age|
--+----+-----+---+
 1|a   |123  | 18|
 2|bb  |1234 |   |
 3|ccc |     |   |
</code></pre><p>对于第一条数据而言：</p>
<ul>
<li>name 列的值为 a，真实数据占用的字节数是 1 字节，十六进制 0x01；</li>
<li>phone 列的值为 123，真实数据占用的字节数是 3 字节，十六进制 0x03；</li>
</ul>
<p>这些变长字段的真实数据占用的字节数会按照列的顺序<strong>逆序存放</strong>（<a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e9%80%86%e5%ba%8f%e5%ad%98%e6%94%be">为什么要逆序存放</a>），所以「变长字段长度列表」里的内容是「 03 01」，而不是 「01 03」。</p>
<p><img src="https://static.jiangliuhong.top/images/2024/1/15mysql_compact1.png" alt="15mysql_compact1.png" /></p>
<p>第二条记录的行格式中，「变长字段长度列表」里的内容是「 04 02」</p>
<p><img src="https://static.jiangliuhong.top/images/2024/1/15mysql_compact2.png" alt="15mysql_compact2.png" /></p>
<p>第三条记录中 phone 列的值是 NULL，NULL 是不会存放在行格式中记录的真实数据部分里的，所以「变长字段长度列表」里不需要保存值为 NULL 的变长字段的长度。</p>
<p><img src="https://static.jiangliuhong.top/images/2024/1/15mysql_compact3.png" alt="15mysql_compact3.png" /></p>
<h3 id="为什么逆序存放">
  为什么逆序存放
  <a class="anchor" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e9%80%86%e5%ba%8f%e5%ad%98%e6%94%be">#</a>
</h3>
<p>当 InnoDB 存储引擎处理一行数据时，它通常是从行的末尾开始向前处理的。这是因为行的末尾通常包含了一些固定长度的信息（如行ID、事务ID等），这些信息的位置是固定的，因此可以很容易地找到。而变长字段则位于这些固定长度信息的前面。</p>
<p>如果按照列的顺序直接存放变长字段的长度值，那么 InnoDB 在处理变长字段时就需要从行的开头开始逐个读取长度值，直到找到目标字段的长度。这样做可能会涉及到多次的磁盘块读写操作，因为每个字段的长度值可能分散在不同的磁盘块中。</p>
<p>但是，如果按照列的顺序逆序存放这些长度值，InnoDB 就可以在处理变长字段时直接从行的末尾开始读取长度值。由于长度值是逆序存放的，因此目标字段的长度值会更快地被找到。这样，InnoDB 就可以更快速地定位到目标字段的数据在磁盘块中的位置，从而减少磁盘 I/O 操作的次数。</p>
<h3 id="记录头信息">
  记录头信息
  <a class="anchor" href="#%e8%ae%b0%e5%bd%95%e5%a4%b4%e4%bf%a1%e6%81%af">#</a>
</h3>
<p>记录头信息是由固定的5个字节组成，5个字节也就是40个二进制位，不同的位代表不同的意思，这些头信息会在后面的一些功能中看到。</p>
<table>
  <thead>
      <tr>
          <th>名称</th>
          <th>大小（单位：bit）</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>预留位1</td>
          <td>1</td>
          <td>没有使用</td>
      </tr>
      <tr>
          <td>预留位2</td>
          <td>1</td>
          <td>没有使用</td>
      </tr>
      <tr>
          <td>delete_mask</td>
          <td>1</td>
          <td>标识此条数据是否被删除。从这里可以知道，我们执行 detele 删除记录的时候，并不会真正的删除记录，只是将这个记录的 delete_mask 标记为 1</td>
      </tr>
      <tr>
          <td>min_rec_mask</td>
          <td>1</td>
          <td>B+树的每层非叶子节点中的最小记录标记为1</td>
      </tr>
      <tr>
          <td>n_owned</td>
          <td>4</td>
          <td>当前记录拥有的记录数</td>
      </tr>
      <tr>
          <td>heap_no</td>
          <td>13</td>
          <td>索引堆中该条记录的排序记录</td>
      </tr>
      <tr>
          <td>record_ type</td>
          <td>3</td>
          <td>记录类型，000（0）表示普通记录，001（1）表示B+树非叶子节点记录，010（2）表示最小记录，011（3）表示最大记录</td>
      </tr>
      <tr>
          <td>next_record</td>
          <td>16</td>
          <td>下一条记录的位置。从这里可以知道，记录与记录之间是通过链表组织的。在前面我也提到了，指向的是下一条记录的「记录头信息」和「真实数据」之间的位置，这样的好处是向左读就是记录头信息，向右读就是真实数据，比较方便</td>
      </tr>
      <tr>
          <td>Total</td>
          <td>40</td>
          <td></td>
      </tr>
  </tbody>
</table>
<p><strong>其中比较重要的是：delete_mask、delete_mask、record_type</strong></p>
<h3 id="null-值列表">
  NULL 值列表
  <a class="anchor" href="#null-%e5%80%bc%e5%88%97%e8%a1%a8">#</a>
</h3>
<p>表中的某些列可能会存储 NULL 值，如果把这些 NULL 值都放到记录的真实数据中会比较浪费空间，所以 Compact 行格式把这些值为 NULL 的列存储到 NULL值列表中。</p>
<p>如果存在允许 NULL 值的列，则每个列对应一个二进制位（bit），二进制位按照列的顺序逆序排列。</p>
<ul>
<li>二进制位的值为<code>1</code>时，代表该列的值为NULL。</li>
<li>二进制位的值为<code>0</code>时，代表该列的值不为NULL。</li>
</ul>
<p>另外，NULL 值列表必须用整数个字节的位表示（1字节8位），如果使用的二进制位个数不足整数个字节，则在字节的高位补 <code>0</code>。</p>
<p>以上面的<code>t_user</code>数据为例：</p>
<p>列数据：</p>
<pre tabindex="0"><code>id|name|phone| age |
--+----+-----+----+
 1|a   |123  | 18 |
 2|bb  |1234 |NULL|
 3|ccc |NULL |NULL|
</code></pre><p>对于第一条记录，所有列都有值，不存在 NULL 值，所以用二进制来表示如下图所示：</p>
<p><img src="https://static.jiangliuhong.top/images/2024/1/15mysql_compact_null1.png" alt="" /></p>
<p>但是 InnoDB 是用整数字节的二进制位来表示 NULL 值列表的，现在不足 8 位，所以要在高位补 0，最终用二进制来表示是下面这样的：</p>
<p><img src="https://static.jiangliuhong.top/images/2024/1/15mysql_compact_null2.png" alt="" /></p>
<p>下面来看第二条记录， age 列是 NULL 值，所以，对于第二条数据，NULL值列表用十六进制表示是 0x04。</p>
<p><img src="https://static.jiangliuhong.top/images/2024/1/15mysql_compact_null3.png" alt="" /></p>
<p>最后第三条记录， phone 列 和 age 列是 NULL 值，所以，对于第三条数据，NULL 值列表用十六进制表示是 0x06。</p>
<p><img src="https://static.jiangliuhong.top/images/2024/1/15mysql_compact_null4.png" alt="" /></p>
<p>当三条记录的 NULL 值列表都填充完毕后，它们的行格式最终是这样的：</p>
<p><img src="https://static.jiangliuhong.top/images/2024/1/15mysql_compact_null5.png" alt="" /></p>
<h3 id="记录的真实数据">
  记录的真实数据
  <a class="anchor" href="#%e8%ae%b0%e5%bd%95%e7%9a%84%e7%9c%9f%e5%ae%9e%e6%95%b0%e6%8d%ae">#</a>
</h3>
<p>记录真实数据部分除了我们定义的字段，还有三个隐藏字段，分别为：row_id、trx_id、roll_pointer</p>
<ul>
<li>
<p>row_id:如果我们建表的时候指定了主键或者唯一约束列，那么就没有 row_id 隐藏字段了。如果既没有指定主键，又没有唯一约束，那么 InnoDB 就会为记录添加 row_id 隐藏字段。row_id不是必需的，占用 6 个字节。</p>
</li>
<li>
<p>trx_id:事务id，表示这个数据是由哪个事务生成的。 trx_id是必需的，占用 6 个字节。</p>
</li>
<li>
<p>roll_pointer:这条记录上一个版本的指针。roll_pointer 是必需的，占用 7 个字节。</p>
</li>
</ul>
<p><img src="https://static.jiangliuhong.top/images/2024/1/16mysql_compact_real.png" alt="16mysql_compact_real.png" /></p>
<p>其中trx_id 和 roll_pointer主要在MVCC 机制中起作用：<a href="../trans#mvcc%e6%9c%ba%e5%88%b6">MVCC机制</a></p>
<h3 id="行溢出处理">
  行溢出处理
  <a class="anchor" href="#%e8%a1%8c%e6%ba%a2%e5%87%ba%e5%a4%84%e7%90%86">#</a>
</h3>
<p>MySQL 中磁盘和内存交互的基本单位是页，一个页的大小一般是 <code>16KB</code>，也就是 <code>16384字节</code>，而一个 varchar(n) 类型的列最多可以存储 <code>65532字节</code>，一些大对象如 TEXT、BLOB 可能存储更多的数据，这时一个页可能就存不了一条记录。这个时候就会<strong>发生行溢出，多的数据就会存到另外的「溢出页」中</strong>。</p>
<p>如果一个数据页存不了一条记录，InnoDB 存储引擎会自动将溢出的数据存放到「溢出页」中。在一般情况下，InnoDB 的数据都是存放在 「数据页」中。但是当发生行溢出时，溢出的数据会存放到「溢出页」中。</p>
<p>当发生行溢出时，在记录的真实数据处只会保存该列的一部分数据，而把剩余的数据放在「溢出页」中，然后真实数据处用 20 字节存储指向溢出页的地址，从而可以找到剩余数据所在的页。大致如下图所示。</p>
<p><img src="https://static.jiangliuhong.top/images/2024/1/16mysql_row.png" alt="16mysql_row.png" /></p>
<p>上面这个是 Compact 行格式在发生行溢出后的处理。</p>
<p>Compressed 和 Dynamic 这两个行格式和 Compact 非常类似，主要的区别在于处理行溢出数据时有些区别。</p>
<p>这两种格式采用完全的行溢出方式，记录的真实数据处不会存储该列的一部分数据，只存储 20 个字节的指针来指向溢出页。而实际的数据都存储在溢出页中，看起来就像下面这样：</p>
<p><img src="https://static.jiangliuhong.top/images/2024/1/16mysql_row2.png" alt="16mysql_row2.png" /></p>
<blockquote>
<p>参考链接：</p>
<p><a href="https://www.cnblogs.com/xiaolincoding/p/16941244.html">MySQL的null值是怎么存储的?</a></p>
<p><a href="https://www.51cto.com/article/771121.html">MySQL 的 NULL 值是怎么存放的?</a></p></blockquote>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#存储的文件">存储的文件</a></li>
    <li><a href="#存储文件结构">存储文件结构</a></li>
    <li><a href="#innodb-行格式">InnoDB 行格式</a>
      <ul>
        <li><a href="#记录的额外信息">记录的额外信息</a></li>
        <li><a href="#变长字段长度列表">变长字段长度列表</a></li>
        <li><a href="#为什么逆序存放">为什么逆序存放</a></li>
        <li><a href="#记录头信息">记录头信息</a></li>
        <li><a href="#null-值列表">NULL 值列表</a></li>
        <li><a href="#记录的真实数据">记录的真实数据</a></li>
        <li><a href="#行溢出处理">行溢出处理</a></li>
      </ul>
    </li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












