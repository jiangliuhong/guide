<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="
  索引概念
  #


  索引是什么
  #

索引是对数据库表中一列或多列的值进行排序的一种数据结构，能实现快速定位数据的一种存储结构，其设计思想是以空间换时间。
在关系型数据库中，索引是一种单独的、物理的对数据库表中的一列或者多列的值进行排序的一种存储结构，它是某个表中一列或若干列值的集合和相应的指向表中物理标识，这些值的数据页的逻辑指针清单。索引的作用相当于图书的目录，可以根据目录中的页码快速找到所需的内容。

  索引的分类
  #

按数据结构分类：

B&#43;tree索引
Hash索引
Full-text 索引

按物理存储分类：

聚簇索引（主键索引）
二级索引（辅助索引）

按字段特性分类：

主键索引
唯一索引
普通索引
前缀索引

按字段个数分类：

单列索引
联合索引


  唯一索引
  #

唯一索引和普通索引类似，主要区别在于，唯一索引限制列的值必须唯一，但允许存在空值（只能有一个）。主键索引不允许有空值。

  全文索引
  #

在执行模糊查询的时候，如like &quot;value%&quot;，这种情况下，需要考虑使用全文搜索的方式进行优化。全文搜索在MySQL中是一个FULLTEXT类型索引。全文索引主要用来查找文本中的关键字，而不是直接与索引中的值进行比较，它更像是一个搜索引擎，而不是简单的where语句的参数匹配。目前只有char/vachar/text列上可以创建全文索引，默认Mysql不支持中文全文搜索。Mysql全文搜索只是一个临时方案，对于全文搜索场景，更专业的做法是使用全文搜索引擎，如ElasticSearch。

  Hash 索引
  #

Hash索引是一种基于哈希算法的索引类型。它通过将索引键值通过哈希函数转换为固定长度的哈希码，然后将哈希码映射到实际存储位置。Hash索引适用于等值查询，例如在WHERE子句中使用=条件。Hash索引适用于等值查询的场景，但由于哈希碰撞（不同键值得到相同的哈希码）可能导致性能下降，因此在某些情况下不如B树索引。

  组合索引
  #

组合索引是指在多个列上创建的索引，这样可以更有效地支持多列的查询条件。组合索引按照索引的列顺序建立，从左到右，左侧列的顺序性更强。当查询中涉及多个列作为查询条件时，组合索引能够更好地提高查询性能。但要注意，组合索引的列顺序要考虑到查询频率较高的列放在前面。

  聚簇索引与非聚簇索引
  #

聚簇索引是一种特殊的索引，它决定了数据表中数据的物理排列顺序，使得索引和数据行保存在一起。InnoDB存储引擎中的主键索引就是聚簇索引。
与聚簇索引相对应的是非聚簇索引。非聚簇索引中索引和数据行是分开存储的，索引仅包含指向实际数据行的指针。
需要注意的是，当查询列不在非聚簇索引上时，会引发回表。

  MySQL 索引机制
  #


  为什么InnoDB要使用 B&#43; 树，而不是 B 树
  #

首先，由于索引本身数据量大，所以只能以索引文件的形式存储在磁盘上，也就导致每次读取索引都会产生磁盘 I/O 消耗，所以选用的数据结构能获取更多的信息并且 I/O 消耗更低就尤为重要。

  B 树概念
  #

B 树是一种自平衡的二叉树，它维护有序数据并允许对树进行搜索、顺序访问、插入和删除。它是二叉搜索树的一种演化，在 B 树中，一个父节点可以有多个子节点。">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:url" content="http://localhost:1313/docs/database/mysql/indexes/">
  <meta property="og:site_name" content="复习吧">
  <meta property="og:title" content="索引概率">
  <meta property="og:description" content="索引概念 # 索引是什么 # 索引是对数据库表中一列或多列的值进行排序的一种数据结构，能实现快速定位数据的一种存储结构，其设计思想是以空间换时间。
在关系型数据库中，索引是一种单独的、物理的对数据库表中的一列或者多列的值进行排序的一种存储结构，它是某个表中一列或若干列值的集合和相应的指向表中物理标识，这些值的数据页的逻辑指针清单。索引的作用相当于图书的目录，可以根据目录中的页码快速找到所需的内容。
索引的分类 # 按数据结构分类：
B&#43;tree索引 Hash索引 Full-text 索引 按物理存储分类：
聚簇索引（主键索引） 二级索引（辅助索引） 按字段特性分类：
主键索引 唯一索引 普通索引 前缀索引 按字段个数分类：
单列索引 联合索引 唯一索引 # 唯一索引和普通索引类似，主要区别在于，唯一索引限制列的值必须唯一，但允许存在空值（只能有一个）。主键索引不允许有空值。
全文索引 # 在执行模糊查询的时候，如like &#34;value%&#34;，这种情况下，需要考虑使用全文搜索的方式进行优化。全文搜索在MySQL中是一个FULLTEXT类型索引。全文索引主要用来查找文本中的关键字，而不是直接与索引中的值进行比较，它更像是一个搜索引擎，而不是简单的where语句的参数匹配。目前只有char/vachar/text列上可以创建全文索引，默认Mysql不支持中文全文搜索。Mysql全文搜索只是一个临时方案，对于全文搜索场景，更专业的做法是使用全文搜索引擎，如ElasticSearch。
Hash 索引 # Hash索引是一种基于哈希算法的索引类型。它通过将索引键值通过哈希函数转换为固定长度的哈希码，然后将哈希码映射到实际存储位置。Hash索引适用于等值查询，例如在WHERE子句中使用=条件。Hash索引适用于等值查询的场景，但由于哈希碰撞（不同键值得到相同的哈希码）可能导致性能下降，因此在某些情况下不如B树索引。
组合索引 # 组合索引是指在多个列上创建的索引，这样可以更有效地支持多列的查询条件。组合索引按照索引的列顺序建立，从左到右，左侧列的顺序性更强。当查询中涉及多个列作为查询条件时，组合索引能够更好地提高查询性能。但要注意，组合索引的列顺序要考虑到查询频率较高的列放在前面。
聚簇索引与非聚簇索引 # 聚簇索引是一种特殊的索引，它决定了数据表中数据的物理排列顺序，使得索引和数据行保存在一起。InnoDB存储引擎中的主键索引就是聚簇索引。
与聚簇索引相对应的是非聚簇索引。非聚簇索引中索引和数据行是分开存储的，索引仅包含指向实际数据行的指针。
需要注意的是，当查询列不在非聚簇索引上时，会引发回表。
MySQL 索引机制 # 为什么InnoDB要使用 B&#43; 树，而不是 B 树 # 首先，由于索引本身数据量大，所以只能以索引文件的形式存储在磁盘上，也就导致每次读取索引都会产生磁盘 I/O 消耗，所以选用的数据结构能获取更多的信息并且 I/O 消耗更低就尤为重要。
B 树概念 # B 树是一种自平衡的二叉树，它维护有序数据并允许对树进行搜索、顺序访问、插入和删除。它是二叉搜索树的一种演化，在 B 树中，一个父节点可以有多个子节点。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="docs">
    <meta property="article:published_time" content="2023-11-25T22:23:59+08:00">
    <meta property="article:modified_time" content="2024-01-21T20:50:05+08:00">
<title>索引概率 | 复习吧</title>
<link rel="manifest" href="/manifest.json">
<link rel="icon" href="/favicon.png" >
<link rel="stylesheet" href="/book.min.cdf2dd29f013b9b416743e9529e3db831a1462598e2803454998241de8e37466.css" integrity="sha256-zfLdKfATubQWdD6VKePbgxoUYlmOKANFSZgkHejjdGY=" crossorigin="anonymous">
  <script defer src="/flexsearch.min.js"></script>
  <script defer src="/en.search.min.80ca7f71d8159d5795f243152f289067a8e79866a78fb2aad41736a324b0b3da.js" integrity="sha256-gMp/cdgVnVeV8kMVLyiQZ6jnmGanj7Kq1Bc2oySws9o=" crossorigin="anonymous"></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><span>复习吧</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>












  <ul>
<li>数据库
<ul>
<li><a href="/docs/database/mysql/">MySQL</a>
<ul>
<li><a href="/docs/database/mysql/indexes/"class=active>索引</a></li>
<li><a href="/docs/database/mysql/trans/">事务</a></li>
<li><a href="/docs/database/mysql/storage/">数据存储</a></li>
<li><a href="/docs/database/mysql/cluster/">集群</a></li>
<li><a href="/docs/database/mysql/normal/">常见面试题</a></li>
</ul>
</li>
<li>NOSQL 数据库
<ul>
<li><a href="/docs/database/redis/">Redis</a>
<ul>
<li><a href="/docs/database/redis/base/">基础概念</a></li>
<li><a href="/docs/database/redis/data/">数据结构</a></li>
<li><a href="/docs/database/redis/high/">高可用</a></li>
<li><a href="/docs/database/redis/apply/">应用实践</a></li>
</ul>
</li>
<li><a href="/docs/database/es/">ElastiSearch</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="/docs/java/">Java</a></li>
<li>算法
<ul>
<li><a href="/docs/arithmetic/data/">数据结构</a></li>
</ul>
</li>
<li>中间件
<ul>
<li><a href="/docs/middleware/messagequeue/">消息队列</a></li>
</ul>
</li>
</ul>










</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>索引概率</strong>

  <label for="toc-control">
    
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#索引是什么">索引是什么</a>
      <ul>
        <li><a href="#索引的分类">索引的分类</a>
          <ul>
            <li><a href="#唯一索引">唯一索引</a></li>
            <li><a href="#全文索引">全文索引</a></li>
            <li><a href="#hash-索引">Hash 索引</a></li>
            <li><a href="#组合索引">组合索引</a></li>
            <li><a href="#聚簇索引与非聚簇索引">聚簇索引与非聚簇索引</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#mysql-索引机制">MySQL 索引机制</a>
      <ul>
        <li><a href="#为什么innodb要使用-b-树而不是-b-树">为什么InnoDB要使用 B+ 树，而不是 B 树</a>
          <ul>
            <li><a href="#b-树概念">B 树概念</a></li>
            <li><a href="#b-树概念-1">B+ 树概念</a></li>
            <li><a href="#b-树与其他数据结构对比">B+ 树与其他数据结构对比</a></li>
            <li><a href="#高度为-3-的-b-树能存多少数据">高度为 3 的 B+ 树能存多少数据</a></li>
          </ul>
        </li>
        <li><a href="#innodb-与-myisam-引擎下的索引区别">InnoDB 与 MyISAM 引擎下的索引区别</a>
          <ul>
            <li><a href="#innodb-中-b-树是如何产生的">Innodb 中 B+ 树是如何产生的</a></li>
            <li><a href="#innodb-是如何支持范围查找能走索引的">Innodb 是如何支持范围查找能走索引的</a></li>
          </ul>
        </li>
        <li><a href="#索引下推">索引下推</a>
          <ul>
            <li><a href="#认识mysql架构">认识mysql架构</a></li>
            <li><a href="#索引下推的作用">索引下推的作用</a></li>
            <li><a href="#索引下推的使用条件">索引下推的使用条件</a></li>
          </ul>
        </li>
        <li><a href="#索引排序内部流程">索引排序内部流程</a></li>
      </ul>
    </li>
    <li><a href="#索引失效">索引失效</a>
      <ul>
        <li><a href="#什么情况下索引失效">什么情况下索引失效</a>
          <ul>
            <li><a href="#字段为-null-索引是否失效">字段为 null 索引是否失效</a></li>
            <li><a href="#like-索引失效问题">LIKE 索引失效问题</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown"><h1 id="索引概念">
  索引概念
  <a class="anchor" href="#%e7%b4%a2%e5%bc%95%e6%a6%82%e5%bf%b5">#</a>
</h1>
<h2 id="索引是什么">
  索引是什么
  <a class="anchor" href="#%e7%b4%a2%e5%bc%95%e6%98%af%e4%bb%80%e4%b9%88">#</a>
</h2>
<p>索引是对数据库表中一列或多列的值进行排序的一种数据结构，能实现快速定位数据的一种存储结构，其设计思想是以空间换时间。</p>
<p>在关系型数据库中，索引是一种单独的、物理的对数据库表中的一列或者多列的值进行排序的一种存储结构，它是某个表中一列或若干列值的集合和相应的指向表中物理标识，这些值的数据页的逻辑指针清单。索引的作用相当于图书的目录，可以根据目录中的页码快速找到所需的内容。</p>
<h3 id="索引的分类">
  索引的分类
  <a class="anchor" href="#%e7%b4%a2%e5%bc%95%e7%9a%84%e5%88%86%e7%b1%bb">#</a>
</h3>
<p>按<strong>数据结构</strong>分类：</p>
<ul>
<li>B+tree索引</li>
<li>Hash索引</li>
<li>Full-text 索引</li>
</ul>
<p>按<strong>物理存储</strong>分类：</p>
<ul>
<li>聚簇索引（主键索引）</li>
<li>二级索引（辅助索引）</li>
</ul>
<p>按<strong>字段特性</strong>分类：</p>
<ul>
<li>主键索引</li>
<li>唯一索引</li>
<li>普通索引</li>
<li>前缀索引</li>
</ul>
<p>按<strong>字段个数</strong>分类：</p>
<ul>
<li>单列索引</li>
<li>联合索引</li>
</ul>
<h4 id="唯一索引">
  唯一索引
  <a class="anchor" href="#%e5%94%af%e4%b8%80%e7%b4%a2%e5%bc%95">#</a>
</h4>
<p>唯一索引和普通索引类似，主要区别在于，唯一索引限制列的值必须唯一，但允许存在空值（只能有一个）。主键索引不允许有空值。</p>
<h4 id="全文索引">
  全文索引
  <a class="anchor" href="#%e5%85%a8%e6%96%87%e7%b4%a2%e5%bc%95">#</a>
</h4>
<p>在执行模糊查询的时候，如<code>like &quot;value%&quot;</code>，这种情况下，需要考虑使用全文搜索的方式进行优化。全文搜索在MySQL中是一个FULLTEXT类型索引。全文索引主要用来查找文本中的关键字，而不是直接与索引中的值进行比较，它更像是一个搜索引擎，而不是简单的where语句的参数匹配。目前只有char/vachar/text列上可以创建全文索引，默认Mysql不支持中文全文搜索。Mysql全文搜索只是一个临时方案，对于全文搜索场景，更专业的做法是使用全文搜索引擎，如ElasticSearch。</p>
<h4 id="hash-索引">
  Hash 索引
  <a class="anchor" href="#hash-%e7%b4%a2%e5%bc%95">#</a>
</h4>
<p>Hash索引是一种基于哈希算法的索引类型。它通过将索引键值通过哈希函数转换为固定长度的哈希码，然后将哈希码映射到实际存储位置。Hash索引适用于等值查询，例如在WHERE子句中使用<code>=</code>条件。Hash索引适用于等值查询的场景，但由于哈希碰撞（不同键值得到相同的哈希码）可能导致性能下降，因此在某些情况下不如B树索引。</p>
<h4 id="组合索引">
  组合索引
  <a class="anchor" href="#%e7%bb%84%e5%90%88%e7%b4%a2%e5%bc%95">#</a>
</h4>
<p>组合索引是指在多个列上创建的索引，这样可以更有效地支持多列的查询条件。组合索引按照索引的列顺序建立，从左到右，左侧列的顺序性更强。当查询中涉及多个列作为查询条件时，组合索引能够更好地提高查询性能。但要注意，组合索引的列顺序要考虑到查询频率较高的列放在前面。</p>
<h4 id="聚簇索引与非聚簇索引">
  聚簇索引与非聚簇索引
  <a class="anchor" href="#%e8%81%9a%e7%b0%87%e7%b4%a2%e5%bc%95%e4%b8%8e%e9%9d%9e%e8%81%9a%e7%b0%87%e7%b4%a2%e5%bc%95">#</a>
</h4>
<p>聚簇索引是一种特殊的索引，它决定了数据表中数据的物理排列顺序，使得索引和数据行保存在一起。InnoDB存储引擎中的主键索引就是聚簇索引。</p>
<p>与聚簇索引相对应的是非聚簇索引。非聚簇索引中索引和数据行是分开存储的，索引仅包含指向实际数据行的指针。</p>
<p>需要注意的是，当查询列不在非聚簇索引上时，会引发回表。</p>
<h2 id="mysql-索引机制">
  MySQL 索引机制
  <a class="anchor" href="#mysql-%e7%b4%a2%e5%bc%95%e6%9c%ba%e5%88%b6">#</a>
</h2>
<h3 id="为什么innodb要使用-b-树而不是-b-树">
  为什么InnoDB要使用 B+ 树，而不是 B 树
  <a class="anchor" href="#%e4%b8%ba%e4%bb%80%e4%b9%88innodb%e8%a6%81%e4%bd%bf%e7%94%a8-b-%e6%a0%91%e8%80%8c%e4%b8%8d%e6%98%af-b-%e6%a0%91">#</a>
</h3>
<p>首先，由于索引本身数据量大，所以只能以索引文件的形式存储在磁盘上，也就导致每次读取索引都会产生磁盘 I/O 消耗，所以选用的数据结构能获取更多的信息并且 I/O 消耗更低就尤为重要。</p>
<h4 id="b-树概念">
  B 树概念
  <a class="anchor" href="#b-%e6%a0%91%e6%a6%82%e5%bf%b5">#</a>
</h4>
<p>B 树是一种自平衡的二叉树，它维护有序数据并允许对树进行搜索、顺序访问、插入和删除。它是二叉搜索树的一种演化，在 B 树中，一个父节点可以有多个子节点。</p>
<p>B 树是一种平衡的多分树，通常我们说 m 阶的 B 树，他必须满足如下条件：</p>
<ul>
<li>每个节点最多有 m 个子节点</li>
<li>每个非叶子节点（除去根节点）具有至少 m/2 个子节点</li>
<li>根节点至少有两个子节点</li>
<li>具有 k 个子节点的非叶子节点包含 k-1 个键</li>
</ul>
<p><img src="https://static.jiangliuhong.top/images/2023/12/131702451517376.png" alt="B树结构" /></p>
<p>B 树的阶，指的是 B 树中节点的子节点数目的最大值。例如在上图的书中，「13,16,19」拥有的子节点数目最多，一共有四个子节点（灰色节点）。所以该 B 树的阶为 4，该树称为 4 阶 B 树。在实际应用中，B 树应用于 MongoDb 的索引。</p>
<h4 id="b-树概念-1">
  B+ 树概念
  <a class="anchor" href="#b-%e6%a0%91%e6%a6%82%e5%bf%b5-1">#</a>
</h4>
<p>B+ 树是由 B 树演变的，是使用文件系统使用的数据结构：</p>
<ul>
<li>有 m 个子树的中间节点包含有 m 个元素，每个元素不保持数据，只作为索引使用。</li>
<li>所有的叶子节点中包含了关键字的信息，以及这些关键字记录的指针，并且叶子节点本身按照关键字的大小从大到小的顺序排列。</li>
</ul>
<p><img src="https://static.jiangliuhong.top/images/2023/12/1416181905626579.jpg" alt="B&#43;树结构" /></p>
<p>与 B 树相比，B+ 树的有点为：</p>
<ul>
<li>B+ 树的磁盘读写代驾更低：B+ 树的内部节点并没有指向关键字的指针信息，所以内部节点所使用的空间更小，对于相同大小能存放的关键字信息就更多，所以一次读入内存的关键字也就更多，从而减少 I/O 次数。</li>
<li>B+ 树查询效率更加稳定：由于 B+ 非终节点并不实际指向文件内容，只是存储叶子节点的关键字索引，所以 B+ 树中任何关键字的查询必须从根节点查询到叶子节点，所有关键字的查询的遍历层级是相同的，也就是导致数据查询效率相当。</li>
<li>B+ 树更适合用于范围查找：对于遍历，B+ 树只需要遍历叶子节点就可以实现整棵树的遍历。</li>
</ul>
<p>总结：</p>
<ul>
<li>B+树是一棵平衡树，每个叶子节点到根节点的路径长度相同，查找效率较高</li>
<li>B+树的所有关键字都在叶子节点上，因此范围查询时只需要遍历一遍叶子节点即可</li>
<li>B+树的叶子节点都按照关键字大小顺序存放，因此可以快速地支持按照关键字大小进行排序</li>
<li>B+树的非叶子节点不存储实际数据，因此可以存储更多的索引/数据；</li>
<li>B+树的非叶子节点使用指针连接子节点，因此可以快速地支持范围查询和倒序查询</li>
<li>B+树的叶子节点之间通过双向链表链接，方便进行范围查询。</li>
</ul>
<h4 id="b-树与其他数据结构对比">
  B+ 树与其他数据结构对比
  <a class="anchor" href="#b-%e6%a0%91%e4%b8%8e%e5%85%b6%e4%bb%96%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e5%af%b9%e6%af%94">#</a>
</h4>
<p>与B 树：</p>
<ul>
<li>B 树非叶子节点也要存储数据，相同磁盘 IO，B+树能查询更多节点</li>
<li>B+树双向链表适合范围查询，B 树的中序遍历会更麻烦</li>
</ul>
<p>二叉树：</p>
<ul>
<li>B+树查询时间复杂度为logdN,二叉树为logN</li>
<li>B+树存储千万数据也需要二～三层，进行二～三次 IO，二叉树则 IO 更多</li>
</ul>
<p>Hash：</p>
<ul>
<li>Hash 无法进行范围查询</li>
<li>Hash维护索引成本更低</li>
</ul>
<p>红黑树：</p>
<ul>
<li>红黑树是一种二叉搜索树，每个节点最多只能包含两个子节点</li>
<li>B树是一种多路搜索树，它的每个节点可以包含多个键值和子节点</li>
<li>红黑树更适用于实现集合和映射等数据结构，以及其它查找频繁的场景</li>
<li>B树更适用于实现数据库索引等需要频繁插入和删除操作的场景</li>
</ul>
<h4 id="高度为-3-的-b-树能存多少数据">
  高度为 3 的 B+ 树能存多少数据
  <a class="anchor" href="#%e9%ab%98%e5%ba%a6%e4%b8%ba-3-%e7%9a%84-b-%e6%a0%91%e8%83%bd%e5%ad%98%e5%a4%9a%e5%b0%91%e6%95%b0%e6%8d%ae">#</a>
</h4>
<p>TODO</p>
<h3 id="innodb-与-myisam-引擎下的索引区别">
  InnoDB 与 MyISAM 引擎下的索引区别
  <a class="anchor" href="#innodb-%e4%b8%8e-myisam-%e5%bc%95%e6%93%8e%e4%b8%8b%e7%9a%84%e7%b4%a2%e5%bc%95%e5%8c%ba%e5%88%ab">#</a>
</h3>
<h4 id="innodb-中-b-树是如何产生的">
  Innodb 中 B+ 树是如何产生的
  <a class="anchor" href="#innodb-%e4%b8%ad-b-%e6%a0%91%e6%98%af%e5%a6%82%e4%bd%95%e4%ba%a7%e7%94%9f%e7%9a%84">#</a>
</h4>
<p>TODO</p>
<h4 id="innodb-是如何支持范围查找能走索引的">
  Innodb 是如何支持范围查找能走索引的
  <a class="anchor" href="#innodb-%e6%98%af%e5%a6%82%e4%bd%95%e6%94%af%e6%8c%81%e8%8c%83%e5%9b%b4%e6%9f%a5%e6%89%be%e8%83%bd%e8%b5%b0%e7%b4%a2%e5%bc%95%e7%9a%84">#</a>
</h4>
<p>TODO</p>
<h3 id="索引下推">
  索引下推
  <a class="anchor" href="#%e7%b4%a2%e5%bc%95%e4%b8%8b%e6%8e%a8">#</a>
</h3>
<p>索引下推（ICP）是 MySQL5.6 针对扫描二级索引的一项优化改造。通过把索引过滤条件下推到存储引擎，来减少 MySQL 存储引擎访问基表的次数以及 MySQL 服务层访问存储引擎的次数。ICP 适用于 MYISAM 和 INNODB 引擎。</p>
<h4 id="认识mysql架构">
  认识mysql架构
  <a class="anchor" href="#%e8%ae%a4%e8%af%86mysql%e6%9e%b6%e6%9e%84">#</a>
</h4>
<p><img src="https://static.jiangliuhong.top/images/2024/1/21704179867555.png" alt="MySQL 架构" /></p>
<ul>
<li>MySQL 服务层：也就是 SERVER 层，用来解析 SQL 的语法、语义、生成查询计划、接管从 MySQL 存储引/擎层上推的数据进行二次过滤等等。</li>
<li>MySQL 存储引擎层：按照 MySQL 服务层下发的请求，通过索引或者全表扫描等方式把数据上传到MySQL 服务层。</li>
<li>MySQL 索引扫描：根据指定索引过滤条件，遍历索引找到索引键对应的主键值后回表过滤剩余过滤条件。</li>
<li>MySQL 索引过滤：通过索引扫描并且基于索引进行二次条件过滤后再回表。</li>
</ul>
<h4 id="索引下推的作用">
  索引下推的作用
  <a class="anchor" href="#%e7%b4%a2%e5%bc%95%e4%b8%8b%e6%8e%a8%e7%9a%84%e4%bd%9c%e7%94%a8">#</a>
</h4>
<p><strong>作用：减少回表次数</strong></p>
<p>现在以一个例子展示索引下推：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#75715e">-- 创建表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">table</span> <span style="color:#66d9ef">user</span> (
</span></span><span style="display:flex;"><span> id int <span style="color:#66d9ef">primary</span> <span style="color:#66d9ef">key</span> <span style="color:#66d9ef">comment</span> <span style="color:#e6db74">&#39;id&#39;</span> ,
</span></span><span style="display:flex;"><span> name varchar(<span style="color:#ae81ff">20</span>) <span style="color:#66d9ef">comment</span> <span style="color:#e6db74">&#39;姓名&#39;</span>,
</span></span><span style="display:flex;"><span> age int <span style="color:#66d9ef">comment</span> <span style="color:#e6db74">&#39;年龄&#39;</span>,
</span></span><span style="display:flex;"><span> card int <span style="color:#66d9ef">comment</span> <span style="color:#e6db74">&#39;身份证&#39;</span>,
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">key</span> idx_name_age (name,age)
</span></span><span style="display:flex;"><span>)engine<span style="color:#f92672">=</span>InnoDB <span style="color:#66d9ef">default</span> charset<span style="color:#f92672">=</span>utf8mb4;
</span></span><span style="display:flex;"><span><span style="color:#75715e">-- 插入数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> <span style="color:#66d9ef">user</span> <span style="color:#66d9ef">values</span> (<span style="color:#ae81ff">1</span>,<span style="color:#e6db74">&#39;李四&#39;</span>,<span style="color:#ae81ff">18</span>,<span style="color:#ae81ff">1</span>),(<span style="color:#ae81ff">2</span>,<span style="color:#e6db74">&#39;李五&#39;</span>,<span style="color:#ae81ff">20</span>,<span style="color:#ae81ff">2</span>),(<span style="color:#ae81ff">3</span>,<span style="color:#e6db74">&#39;王五&#39;</span>,<span style="color:#ae81ff">23</span>,<span style="color:#ae81ff">3</span>),(<span style="color:#ae81ff">4</span>,<span style="color:#e6db74">&#39;张三&#39;</span>,<span style="color:#ae81ff">30</span>,<span style="color:#ae81ff">4</span>);
</span></span></code></pre></div><p>查询执行计划：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">explain</span> <span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> <span style="color:#66d9ef">user</span> <span style="color:#66d9ef">where</span> name <span style="color:#66d9ef">like</span> <span style="color:#e6db74">&#39;李%&#39;</span> <span style="color:#66d9ef">and</span> age <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">18</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">-- 结果为：Using where
</span></span></span></code></pre></div><p>设置索引下推</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">SET</span> optimizer_switch<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;index_condition_pushdown=on&#39;</span>;
</span></span></code></pre></div><p>再次查询执行记录</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">explain</span> <span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> <span style="color:#66d9ef">user</span> <span style="color:#66d9ef">where</span> name <span style="color:#66d9ef">like</span> <span style="color:#e6db74">&#39;李%&#39;</span> <span style="color:#66d9ef">and</span> age <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">18</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">-- 结果为：Using index condition
</span></span></span></code></pre></div><p>从索引计划可以看出，执行计划打印为<code>Using index condition</code>则代表使用了索引下推。</p>
<p>假设执行sql为<code>select * from user where name like '李%' and age = 18</code>，通过下面的图可以很明显的看见两种情况下的查询逻辑</p>
<p>未使用索引下推时的查询：</p>
<p><img src="https://static.jiangliuhong.top/images/2024/1/31704273987720.png" alt="未使用索引下推时的查询" /></p>
<p>使用索引下推时的查询：</p>
<p><img src="https://static.jiangliuhong.top/images/2024/1/31704274030853.png" alt="使用索引下推时的查询" /></p>
<p>命令总结：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">＃</span> <span style="color:#960050;background-color:#1e0010">查看索引下推是否开启</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">select</span> <span style="color:#f92672">@@</span>optimizer_switch
</span></span><span style="display:flex;"><span><span style="color:#f92672">#</span><span style="color:#960050;background-color:#1e0010">开启索引下推</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">SET</span> optimizer_switch<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;index_condition_pushdown=on&#39;</span>;
</span></span><span style="display:flex;"><span><span style="color:#f92672">#</span> <span style="color:#960050;background-color:#1e0010">关闭索引下推</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">SET</span> optimizer_Switch<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;index_condition_pushdown=off&#34;</span>;
</span></span></code></pre></div><h4 id="索引下推的使用条件">
  索引下推的使用条件
  <a class="anchor" href="#%e7%b4%a2%e5%bc%95%e4%b8%8b%e6%8e%a8%e7%9a%84%e4%bd%bf%e7%94%a8%e6%9d%a1%e4%bb%b6">#</a>
</h4>
<ul>
<li>索引下推的目标是减少全行记录读取，从而减少 IO 操作，只能用于非聚簇索引。（聚簇索引本身已包含行数据，不存在回表）</li>
<li>只能用于 <code>range</code>、<code>ref</code>、<code>eq_ref</code>、<code>ref_or_null</code>等操作</li>
<li>where条件中使用and的时候（or为排除记录，不需要查询行数据）</li>
<li>适用于分区表</li>
<li>不支持在虚拟列上建立索引（例如：函数索引）</li>
<li>不支持引用子查询作为查询条件</li>
<li>不支持存储函数作为条件，因为在存储引擎中无法调用存储函数</li>
</ul>
<h3 id="索引排序内部流程">
  索引排序内部流程
  <a class="anchor" href="#%e7%b4%a2%e5%bc%95%e6%8e%92%e5%ba%8f%e5%86%85%e9%83%a8%e6%b5%81%e7%a8%8b">#</a>
</h3>
<h2 id="索引失效">
  索引失效
  <a class="anchor" href="#%e7%b4%a2%e5%bc%95%e5%a4%b1%e6%95%88">#</a>
</h2>
<h3 id="什么情况下索引失效">
  什么情况下索引失效
  <a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%83%85%e5%86%b5%e4%b8%8b%e7%b4%a2%e5%bc%95%e5%a4%b1%e6%95%88">#</a>
</h3>
<p>在MySQL8中，索引失效的场景有：</p>
<ul>
<li><code>like</code>查询左边带<code>%</code>时可能会失效</li>
<li>隐式类型转换，即索引字段与查询条件或关联字段类型不一致，MySQL会对其进行类型转换，从而导致索引失效</li>
<li><code>where</code>条件中对索引列使用运算符或函数会导致失效</li>
<li>使用<code>OR</code>查询，并且存在非索引时会导致失效</li>
<li>使用<code>IN</code>查询可能会导致索引失效，在 MySQL 中，通过环境变量<code>eq_range_index_dive_limt</code>的值从而影响 <code>IN</code>查询，在 MySQL8 中，当该值 为 200 时，使用 IN 查询的条件个数大于 200则不会走索引</li>
<li>使用非主键进行范围查询时，可能会失效</li>
<li>使用<code>order by</code>可能会导致失效</li>
<li><code>is null</code>、<code>is not null</code> <code>≠</code>可能会失效</li>
</ul>
<h4 id="字段为-null-索引是否失效">
  字段为 null 索引是否失效
  <a class="anchor" href="#%e5%ad%97%e6%ae%b5%e4%b8%ba-null-%e7%b4%a2%e5%bc%95%e6%98%af%e5%90%a6%e5%a4%b1%e6%95%88">#</a>
</h4>
<p>在MySQL中，对于字段为null的情况，索引并不会失效，而是涉及到优化器的选择。MySQL会考虑走索引与不走索引的成本，并在执行查询时选择最优的执行计划。</p>
<p>对于字段为null的情况，使用<code>is null</code>、<code>is not null</code>或 <code>≠</code>条件，索引仍然可以被利用。优化器会计算索引扫描的成本以及回表操作的成本。如果走索引扫描的效率高于全表扫描，优化器将选择使用索引扫描，然后进行回表操作。</p>
<p>需要注意的是，如果结果列的大小相对于行数量较小，优化器更倾向于执行索引扫描。这是因为索引扫描后再回表的成本相对较低。反之，如果结果列数量较大，那么索引扫描后再回表的效率可能远低于全表扫描，此时优化器可能选择不使用索引。</p>
<p>因此，索引对于字段为null的情况并不失效，而是在优化器根据具体情况进行智能选择，以提高查询性能。</p>
<p>首先<code>is null</code>、<code>is not null</code> <code>≠</code>都是可以走索引的，在MySQL中，MySQL会计算走索引与不走索引的成本，因为如果走索引扫描，那么必然会存在回表操作，MySQL 会计算结果列的大小，如果结果列远低于行数量，那么优化器就会执行索引扫描，然后再回表查询数据，反之，如果结果列数量较大，那么索引扫描后再回表的效率就远低于全表扫描。</p>
<p>关于mysql null值更详细的说明：<a href="../storage#null%e5%80%bc%e7%9a%84%e5%ad%98%e5%82%a8">null值的存储</a></p>
<h4 id="like-索引失效问题">
  LIKE 索引失效问题
  <a class="anchor" href="#like-%e7%b4%a2%e5%bc%95%e5%a4%b1%e6%95%88%e9%97%ae%e9%a2%98">#</a>
</h4>
<p>首先索引的数据结构是B+树，在 B+ 树中，数据是有序的，从下图中可以看出 4 个aba -&gt; abb -&gt; abc -&gt; abc -&gt; abe 是有序排列的，当输入条件为 like &lsquo;a%&lsquo;时，在 B+ 树中是有序查找，所以like前模糊匹配是可以走索引的，但如果缓存后模糊匹配，由于结尾并不是有序排列的，所以此时索引会失效。</p>
<p><img src="https://static.jiangliuhong.top/images/2024/1/151705284761044.png" alt="151705284761044.png" /></p>
<p>但是在某些特定情况，前模糊匹配也可能失效：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#75715e">-- 创建表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">table</span> <span style="color:#66d9ef">user</span> (
</span></span><span style="display:flex;"><span> id int <span style="color:#66d9ef">primary</span> <span style="color:#66d9ef">key</span> <span style="color:#66d9ef">comment</span> <span style="color:#e6db74">&#39;id&#39;</span> ,
</span></span><span style="display:flex;"><span> name varchar(<span style="color:#ae81ff">20</span>) <span style="color:#66d9ef">comment</span> <span style="color:#e6db74">&#39;姓名&#39;</span>,
</span></span><span style="display:flex;"><span> card int <span style="color:#66d9ef">comment</span> <span style="color:#e6db74">&#39;身份证&#39;</span>,
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">key</span> idx_name (name)
</span></span><span style="display:flex;"><span>)engine<span style="color:#f92672">=</span>InnoDB <span style="color:#66d9ef">default</span> charset<span style="color:#f92672">=</span>utf8mb4;
</span></span><span style="display:flex;"><span><span style="color:#75715e">-- 插入数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> <span style="color:#66d9ef">user</span> <span style="color:#66d9ef">values</span> (<span style="color:#ae81ff">1</span>,<span style="color:#e6db74">&#39;李四&#39;</span>,<span style="color:#ae81ff">1</span>),(<span style="color:#ae81ff">2</span>,<span style="color:#e6db74">&#39;李五&#39;</span>,<span style="color:#ae81ff">2</span>),(<span style="color:#ae81ff">3</span>,<span style="color:#e6db74">&#39;王五&#39;</span>,<span style="color:#ae81ff">3</span>),(<span style="color:#ae81ff">4</span>,<span style="color:#e6db74">&#39;张三&#39;</span>,<span style="color:#ae81ff">4</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">-- 创建表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">table</span> user_exp(
</span></span><span style="display:flex;"><span>	id int <span style="color:#66d9ef">primary</span> <span style="color:#66d9ef">key</span> <span style="color:#66d9ef">comment</span> <span style="color:#e6db74">&#39;id&#39;</span>,
</span></span><span style="display:flex;"><span>  name varchar(<span style="color:#ae81ff">20</span>) <span style="color:#66d9ef">comment</span> <span style="color:#e6db74">&#39;姓名&#39;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">key</span> idx_name (name)
</span></span><span style="display:flex;"><span>)engine<span style="color:#f92672">=</span>InnoDB <span style="color:#66d9ef">default</span> charset<span style="color:#f92672">=</span>utf8mb4;
</span></span><span style="display:flex;"><span><span style="color:#75715e">-- 插入数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> user_exp <span style="color:#66d9ef">values</span> (<span style="color:#ae81ff">1</span>,<span style="color:#e6db74">&#39;李四&#39;</span>),(<span style="color:#ae81ff">2</span>,<span style="color:#e6db74">&#39;李五&#39;</span>),(<span style="color:#ae81ff">3</span>,<span style="color:#e6db74">&#39;王五&#39;</span>),(<span style="color:#ae81ff">4</span>,<span style="color:#e6db74">&#39;张三&#39;</span>);
</span></span></code></pre></div><p>执行：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">explain</span> <span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> <span style="color:#66d9ef">user</span> <span style="color:#66d9ef">where</span> name <span style="color:#66d9ef">like</span> <span style="color:#e6db74">&#39;%五&#39;</span>;
</span></span></code></pre></div><p>打印结果为：</p>
<pre tabindex="0"><code>id|select_type|table|partitions|type|possible_keys|key|key_len|ref|rows|filtered|Extra      |
--+-----------+-----+----------+----+-------------+---+-------+---+----+--------+-----------+
 1|SIMPLE     |user |          |ALL |             |   |       |   |   4|    25.0|Using where|
</code></pre><p>执行：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">explain</span> <span style="color:#66d9ef">select</span> id,name <span style="color:#66d9ef">from</span> <span style="color:#66d9ef">user</span> <span style="color:#66d9ef">where</span> name <span style="color:#66d9ef">like</span> <span style="color:#e6db74">&#39;%五&#39;</span>;
</span></span></code></pre></div><p>结果：</p>
<pre tabindex="0"><code>id|select_type|table|partitions|type |possible_keys|key     |key_len|ref|rows|filtered|Extra                   |
--+-----------+-----+----------+-----+-------------+--------+-------+---+----+--------+------------------------+
 1|SIMPLE     |user |          |index|             |idx_name|83     |   |   4|    25.0|Using where; Using index|
</code></pre><p>执行：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">explain</span> <span style="color:#66d9ef">select</span> id,name <span style="color:#66d9ef">from</span> <span style="color:#66d9ef">user</span> <span style="color:#66d9ef">where</span> user_exp <span style="color:#66d9ef">like</span> <span style="color:#e6db74">&#39;%五&#39;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">explain</span> <span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> <span style="color:#66d9ef">user</span> <span style="color:#66d9ef">where</span> user_exp <span style="color:#66d9ef">like</span> <span style="color:#e6db74">&#39;%五&#39;</span>;
</span></span></code></pre></div><p>两个的结果均为：</p>
<pre tabindex="0"><code>id|select_type|table   |partitions|type |possible_keys|key     |key_len|ref|rows|filtered|Extra                   |
--+-----------+--------+----------+-----+-------------+--------+-------+---+----+--------+------------------------+
 1|SIMPLE     |user_exp|          |index|             |idx_name|83     |   |   4|    25.0|Using where; Using index|
</code></pre><p>对于上面的例子，首先我们需要查询的 <code>id</code>、<code> name</code> 这两个字段都在我们的辅助索引中，叶子节点存的索引值和主键值，所以我们只要查辅助索引就可以直接拿到我们的需要的结果了，那么这个叫做索引|覆盖。我们观察执行计划会发现它的查询级别是 index，其实也是全表遍历了辅助索引。</p>
<p>对于第一个例子，查询的是所有字段，而<code>card</code>字段不在辅助索引中，如果遍历辅助索引，则还需要回标，效率远没有直接遍历高。</p>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#索引是什么">索引是什么</a>
      <ul>
        <li><a href="#索引的分类">索引的分类</a>
          <ul>
            <li><a href="#唯一索引">唯一索引</a></li>
            <li><a href="#全文索引">全文索引</a></li>
            <li><a href="#hash-索引">Hash 索引</a></li>
            <li><a href="#组合索引">组合索引</a></li>
            <li><a href="#聚簇索引与非聚簇索引">聚簇索引与非聚簇索引</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#mysql-索引机制">MySQL 索引机制</a>
      <ul>
        <li><a href="#为什么innodb要使用-b-树而不是-b-树">为什么InnoDB要使用 B+ 树，而不是 B 树</a>
          <ul>
            <li><a href="#b-树概念">B 树概念</a></li>
            <li><a href="#b-树概念-1">B+ 树概念</a></li>
            <li><a href="#b-树与其他数据结构对比">B+ 树与其他数据结构对比</a></li>
            <li><a href="#高度为-3-的-b-树能存多少数据">高度为 3 的 B+ 树能存多少数据</a></li>
          </ul>
        </li>
        <li><a href="#innodb-与-myisam-引擎下的索引区别">InnoDB 与 MyISAM 引擎下的索引区别</a>
          <ul>
            <li><a href="#innodb-中-b-树是如何产生的">Innodb 中 B+ 树是如何产生的</a></li>
            <li><a href="#innodb-是如何支持范围查找能走索引的">Innodb 是如何支持范围查找能走索引的</a></li>
          </ul>
        </li>
        <li><a href="#索引下推">索引下推</a>
          <ul>
            <li><a href="#认识mysql架构">认识mysql架构</a></li>
            <li><a href="#索引下推的作用">索引下推的作用</a></li>
            <li><a href="#索引下推的使用条件">索引下推的使用条件</a></li>
          </ul>
        </li>
        <li><a href="#索引排序内部流程">索引排序内部流程</a></li>
      </ul>
    </li>
    <li><a href="#索引失效">索引失效</a>
      <ul>
        <li><a href="#什么情况下索引失效">什么情况下索引失效</a>
          <ul>
            <li><a href="#字段为-null-索引是否失效">字段为 null 索引是否失效</a></li>
            <li><a href="#like-索引失效问题">LIKE 索引失效问题</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












