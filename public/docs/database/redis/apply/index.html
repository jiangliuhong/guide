<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="
  应用实践
  #


  缓存场景问题
  #

常见的redis问题主要有：

缓存和数据库双写一致性问题
缓存雪崩问题
缓存击穿问题
缓存穿透问题
缓存的并发竞争问题


  双写一致性如何保证
  #


  什么一致性
  #

首先是一致性问题，在分布式系统中，可以理解为多个节点中数据的值是一致的。

强一致性：这种一致性级别是最符合用户直觉的，它要求系统写入什么，读出来的也会是什么，用户体验好，但实现起来往往对系统的性能影响大
弱一致性：这种一致性级别约束了系统在写入成功后，不承诺立即可以读到写入的值，也不承诺多久之后数据能够达到一致，但会尽可能地保证到某个时间级别（比如秒级别）后，数据能够达到一致状态
最终一致性：最终一致性是弱一致性的一个特例，系统会保证在一定时间内，能够达到一个数据一致的状态。这里之所以将最终一致性单独提出来，是因为它是弱一致性中非常推崇的一种一致性模型，也是业界在大型分布式系统的数据一致性上比较推崇的模型


  三个经典缓存模式
  #

缓存可以提升性能、缓解数据库压力，但是使用缓存也会导致数据不一致性的问题。一般使用缓存的方式有三种：

Cache-Aside Pattern，旁路缓存模式，主要特点为：

读的时候，先读缓存，缓存命中的话，直接返回数据
缓存没有命中的话，就去读数据库，从数据库取出数据，放入缓存后，同时返回响应。
更新时先更新数据库，然后再删除缓存


Read-Through/Write through，读写穿透模式，服务端把缓存作为主要数据存储。应用程序跟数据库缓存交互，都是通过抽象缓存层完成的。

从缓存读取数据，读到直接返回
如果读取不到的话，从数据库加载，写入缓存后，再返回响应。
与Cache-Aside相似，仅是在它之上增加了一个抽象层


Write behind，异步缓存写入模式

与Read-Through/Write-Through类似，都有一个抽象层负责缓存和数据库的读写
不同的是，Write Behind只负责更新缓存，不直接对数据库进行操作，他通过异步的批量操作的方式去更新数据库
这种方式下，缓存和数据库的一致性不强，对一致性要求高的系统要谨慎使用
适合频繁写的场景，MySQL的InnoDB Buffer Pool机制就使用到这种模式。




  缓存数据更新
  #

在操作缓存的时候，是应该去更新缓存，还是删除后重建？
一般情况下，我们是删除缓存，再下次读取时，获取到数据库数据后再新建缓存数据。
对于这两种的选择的情况一般如下
删除缓存的场景：

写入场景较多（当然写的场景较多的情况下，也需要考虑是否需要引入缓存）
缓存计算逻辑复杂

更新缓存的场景：

写数据库较少
更新频率低


  双写情况下，是先操作数据库还是缓存
  #

Cache-Aside缓存模式中，在写入请求的时候，为什么是先操作数据库呢？为什么不先操作缓存呢？
由于使用的是删除缓存的方式，如果是先操作缓存再操作数据库，此时两个线程并发读写，就会可能出现缓存中的数据与数据库数据不一致的问题。

  保证一致性的一些方法
  #


  同事务强一致性
  #

对于非分布式系统而言，我们可以使数据库操作与redis操作在同一个事务中，具体流程是：

开启事务
修改数据库
执行redis命令
提交事务

基于这种方式，可以保证数据库被修改，缓存一定被删除，但这种方式局限较多。">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:url" content="http://localhost:1313/docs/database/redis/apply/">
  <meta property="og:site_name" content="复习吧">
  <meta property="og:title" content="Redis应用实践">
  <meta property="og:description" content="应用实践 # 缓存场景问题 # 常见的redis问题主要有：
缓存和数据库双写一致性问题 缓存雪崩问题 缓存击穿问题 缓存穿透问题 缓存的并发竞争问题 双写一致性如何保证 # 什么一致性 # 首先是一致性问题，在分布式系统中，可以理解为多个节点中数据的值是一致的。
强一致性：这种一致性级别是最符合用户直觉的，它要求系统写入什么，读出来的也会是什么，用户体验好，但实现起来往往对系统的性能影响大 弱一致性：这种一致性级别约束了系统在写入成功后，不承诺立即可以读到写入的值，也不承诺多久之后数据能够达到一致，但会尽可能地保证到某个时间级别（比如秒级别）后，数据能够达到一致状态 最终一致性：最终一致性是弱一致性的一个特例，系统会保证在一定时间内，能够达到一个数据一致的状态。这里之所以将最终一致性单独提出来，是因为它是弱一致性中非常推崇的一种一致性模型，也是业界在大型分布式系统的数据一致性上比较推崇的模型 三个经典缓存模式 # 缓存可以提升性能、缓解数据库压力，但是使用缓存也会导致数据不一致性的问题。一般使用缓存的方式有三种：
Cache-Aside Pattern，旁路缓存模式，主要特点为： 读的时候，先读缓存，缓存命中的话，直接返回数据 缓存没有命中的话，就去读数据库，从数据库取出数据，放入缓存后，同时返回响应。 更新时先更新数据库，然后再删除缓存 Read-Through/Write through，读写穿透模式，服务端把缓存作为主要数据存储。应用程序跟数据库缓存交互，都是通过抽象缓存层完成的。 从缓存读取数据，读到直接返回 如果读取不到的话，从数据库加载，写入缓存后，再返回响应。 与Cache-Aside相似，仅是在它之上增加了一个抽象层 Write behind，异步缓存写入模式 与Read-Through/Write-Through类似，都有一个抽象层负责缓存和数据库的读写 不同的是，Write Behind只负责更新缓存，不直接对数据库进行操作，他通过异步的批量操作的方式去更新数据库 这种方式下，缓存和数据库的一致性不强，对一致性要求高的系统要谨慎使用 适合频繁写的场景，MySQL的InnoDB Buffer Pool机制就使用到这种模式。 缓存数据更新 # 在操作缓存的时候，是应该去更新缓存，还是删除后重建？
一般情况下，我们是删除缓存，再下次读取时，获取到数据库数据后再新建缓存数据。
对于这两种的选择的情况一般如下
删除缓存的场景：
写入场景较多（当然写的场景较多的情况下，也需要考虑是否需要引入缓存） 缓存计算逻辑复杂 更新缓存的场景：
写数据库较少 更新频率低 双写情况下，是先操作数据库还是缓存 # Cache-Aside缓存模式中，在写入请求的时候，为什么是先操作数据库呢？为什么不先操作缓存呢？
由于使用的是删除缓存的方式，如果是先操作缓存再操作数据库，此时两个线程并发读写，就会可能出现缓存中的数据与数据库数据不一致的问题。
保证一致性的一些方法 # 同事务强一致性 # 对于非分布式系统而言，我们可以使数据库操作与redis操作在同一个事务中，具体流程是：
开启事务 修改数据库 执行redis命令 提交事务 基于这种方式，可以保证数据库被修改，缓存一定被删除，但这种方式局限较多。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="docs">
    <meta property="article:published_time" content="2024-02-16T11:53:59+08:00">
    <meta property="article:modified_time" content="2024-02-20T10:49:00+08:00">
<title>Redis应用实践 | 复习吧</title>
<link rel="manifest" href="/manifest.json">
<link rel="icon" href="/favicon.png" >
<link rel="stylesheet" href="/book.min.cdf2dd29f013b9b416743e9529e3db831a1462598e2803454998241de8e37466.css" integrity="sha256-zfLdKfATubQWdD6VKePbgxoUYlmOKANFSZgkHejjdGY=" crossorigin="anonymous">
  <script defer src="/flexsearch.min.js"></script>
  <script defer src="/en.search.min.80ca7f71d8159d5795f243152f289067a8e79866a78fb2aad41736a324b0b3da.js" integrity="sha256-gMp/cdgVnVeV8kMVLyiQZ6jnmGanj7Kq1Bc2oySws9o=" crossorigin="anonymous"></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><span>复习吧</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>












  <ul>
<li>数据库
<ul>
<li><a href="/docs/database/mysql/">MySQL</a>
<ul>
<li><a href="/docs/database/mysql/indexes/">索引</a></li>
<li><a href="/docs/database/mysql/trans/">事务</a></li>
<li><a href="/docs/database/mysql/storage/">数据存储</a></li>
<li><a href="/docs/database/mysql/cluster/">集群</a></li>
<li><a href="/docs/database/mysql/normal/">常见面试题</a></li>
</ul>
</li>
<li>NOSQL 数据库
<ul>
<li><a href="/docs/database/redis/">Redis</a>
<ul>
<li><a href="/docs/database/redis/base/">基础概念</a></li>
<li><a href="/docs/database/redis/data/">数据结构</a></li>
<li><a href="/docs/database/redis/high/">高可用</a></li>
<li><a href="/docs/database/redis/apply/"class=active>应用实践</a></li>
</ul>
</li>
<li><a href="/docs/database/es/">ElastiSearch</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="/docs/java/">Java</a></li>
<li>算法
<ul>
<li><a href="/docs/arithmetic/data/">数据结构</a></li>
</ul>
</li>
<li>中间件
<ul>
<li><a href="/docs/middleware/messagequeue/">消息队列</a></li>
</ul>
</li>
</ul>










</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>Redis应用实践</strong>

  <label for="toc-control">
    
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#缓存场景问题">缓存场景问题</a>
      <ul>
        <li><a href="#双写一致性如何保证">双写一致性如何保证</a>
          <ul>
            <li><a href="#什么一致性">什么一致性</a></li>
            <li><a href="#三个经典缓存模式">三个经典缓存模式</a></li>
            <li><a href="#缓存数据更新">缓存数据更新</a></li>
            <li><a href="#双写情况下是先操作数据库还是缓存">双写情况下，是先操作数据库还是缓存</a></li>
            <li><a href="#保证一致性的一些方法">保证一致性的一些方法</a>
              <ul>
                <li><a href="#同事务强一致性">同事务强一致性</a></li>
                <li><a href="#缓存延时双删">缓存延时双删</a></li>
                <li><a href="#删除缓存重试机制">删除缓存重试机制</a></li>
                <li><a href="#通过binlog异步删除缓存">通过binlog异步删除缓存</a></li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#缓存雪崩">缓存雪崩</a>
      <ul>
        <li><a href="#什么是缓存雪崩">什么是缓存雪崩</a></li>
      </ul>
    </li>
    <li><a href="#缓存击穿">缓存击穿</a></li>
    <li><a href="#缓存穿透">缓存穿透</a></li>
    <li><a href="#缓存的并发竞争">缓存的并发竞争</a></li>
    <li><a href="#布隆过滤器">布隆过滤器</a>
      <ul>
        <li><a href="#redisson实现布隆过滤器">Redisson实现布隆过滤器</a></li>
        <li><a href="#guava实现布隆过滤器">guava实现布隆过滤器</a></li>
        <li><a href="#redis-布隆过滤器插件">redis 布隆过滤器插件</a></li>
      </ul>
    </li>
    <li><a href="#性能调优">性能调优</a></li>
    <li><a href="#spring-集成">spring 集成</a></li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown"><h1 id="应用实践">
  应用实践
  <a class="anchor" href="#%e5%ba%94%e7%94%a8%e5%ae%9e%e8%b7%b5">#</a>
</h1>
<h2 id="缓存场景问题">
  缓存场景问题
  <a class="anchor" href="#%e7%bc%93%e5%ad%98%e5%9c%ba%e6%99%af%e9%97%ae%e9%a2%98">#</a>
</h2>
<p>常见的redis问题主要有：</p>
<ol>
<li>缓存和数据库双写一致性问题</li>
<li>缓存雪崩问题</li>
<li>缓存击穿问题</li>
<li>缓存穿透问题</li>
<li>缓存的并发竞争问题</li>
</ol>
<h3 id="双写一致性如何保证">
  双写一致性如何保证
  <a class="anchor" href="#%e5%8f%8c%e5%86%99%e4%b8%80%e8%87%b4%e6%80%a7%e5%a6%82%e4%bd%95%e4%bf%9d%e8%af%81">#</a>
</h3>
<h4 id="什么一致性">
  什么一致性
  <a class="anchor" href="#%e4%bb%80%e4%b9%88%e4%b8%80%e8%87%b4%e6%80%a7">#</a>
</h4>
<p>首先是一致性问题，在分布式系统中，可以理解为多个节点中数据的值是一致的。</p>
<ul>
<li>强一致性：这种一致性级别是最符合用户直觉的，它要求系统写入什么，读出来的也会是什么，用户体验好，但实现起来往往对系统的性能影响大</li>
<li>弱一致性：这种一致性级别约束了系统在写入成功后，不承诺立即可以读到写入的值，也不承诺多久之后数据能够达到一致，但会尽可能地保证到某个时间级别（比如秒级别）后，数据能够达到一致状态</li>
<li>最终一致性：最终一致性是弱一致性的一个特例，系统会保证在一定时间内，能够达到一个数据一致的状态。这里之所以将最终一致性单独提出来，是因为它是弱一致性中非常推崇的一种一致性模型，也是业界在大型分布式系统的数据一致性上比较推崇的模型</li>
</ul>
<h4 id="三个经典缓存模式">
  三个经典缓存模式
  <a class="anchor" href="#%e4%b8%89%e4%b8%aa%e7%bb%8f%e5%85%b8%e7%bc%93%e5%ad%98%e6%a8%a1%e5%bc%8f">#</a>
</h4>
<p>缓存可以提升性能、缓解数据库压力，但是使用缓存也会导致数据不一致性的问题。一般使用缓存的方式有三种：</p>
<ul>
<li>Cache-Aside Pattern，旁路缓存模式，主要特点为：
<ul>
<li>读的时候，先读缓存，缓存命中的话，直接返回数据</li>
<li>缓存没有命中的话，就去读数据库，从数据库取出数据，放入缓存后，同时返回响应。</li>
<li>更新时先更新数据库，然后再删除缓存</li>
</ul>
</li>
<li>Read-Through/Write through，读写穿透模式，服务端把缓存作为主要数据存储。应用程序跟数据库缓存交互，都是通过抽象缓存层完成的。
<ul>
<li>从缓存读取数据，读到直接返回</li>
<li>如果读取不到的话，从数据库加载，写入缓存后，再返回响应。</li>
<li>与Cache-Aside相似，仅是在它之上增加了一个抽象层</li>
</ul>
</li>
<li>Write behind，异步缓存写入模式
<ul>
<li>与Read-Through/Write-Through类似，都有一个抽象层负责缓存和数据库的读写</li>
<li>不同的是，Write Behind只负责更新缓存，不直接对数据库进行操作，他通过异步的批量操作的方式去更新数据库</li>
<li>这种方式下，缓存和数据库的一致性不强，对一致性要求高的系统要谨慎使用</li>
<li>适合频繁写的场景，MySQL的InnoDB Buffer Pool机制就使用到这种模式。</li>
</ul>
</li>
</ul>
<h4 id="缓存数据更新">
  缓存数据更新
  <a class="anchor" href="#%e7%bc%93%e5%ad%98%e6%95%b0%e6%8d%ae%e6%9b%b4%e6%96%b0">#</a>
</h4>
<p>在操作缓存的时候，是应该去更新缓存，还是删除后重建？</p>
<p>一般情况下，我们是删除缓存，再下次读取时，获取到数据库数据后再新建缓存数据。</p>
<p>对于这两种的选择的情况一般如下</p>
<p>删除缓存的场景：</p>
<ul>
<li>写入场景较多（当然写的场景较多的情况下，也需要考虑是否需要引入缓存）</li>
<li>缓存计算逻辑复杂</li>
</ul>
<p>更新缓存的场景：</p>
<ul>
<li>写数据库较少</li>
<li>更新频率低</li>
</ul>
<h4 id="双写情况下是先操作数据库还是缓存">
  双写情况下，是先操作数据库还是缓存
  <a class="anchor" href="#%e5%8f%8c%e5%86%99%e6%83%85%e5%86%b5%e4%b8%8b%e6%98%af%e5%85%88%e6%93%8d%e4%bd%9c%e6%95%b0%e6%8d%ae%e5%ba%93%e8%bf%98%e6%98%af%e7%bc%93%e5%ad%98">#</a>
</h4>
<p>Cache-Aside缓存模式中，在写入请求的时候，为什么是先操作数据库呢？为什么不先操作缓存呢？</p>
<p>由于使用的是删除缓存的方式，如果是先操作缓存再操作数据库，此时两个线程并发读写，就会可能出现缓存中的数据与数据库数据不一致的问题。</p>
<h4 id="保证一致性的一些方法">
  保证一致性的一些方法
  <a class="anchor" href="#%e4%bf%9d%e8%af%81%e4%b8%80%e8%87%b4%e6%80%a7%e7%9a%84%e4%b8%80%e4%ba%9b%e6%96%b9%e6%b3%95">#</a>
</h4>
<h5 id="同事务强一致性">
  同事务强一致性
  <a class="anchor" href="#%e5%90%8c%e4%ba%8b%e5%8a%a1%e5%bc%ba%e4%b8%80%e8%87%b4%e6%80%a7">#</a>
</h5>
<p>对于非分布式系统而言，我们可以使数据库操作与redis操作在同一个事务中，具体流程是：</p>
<ol>
<li>开启事务</li>
<li>修改数据库</li>
<li>执行redis命令</li>
<li>提交事务</li>
</ol>
<p>基于这种方式，可以保证数据库被修改，缓存一定被删除，但这种方式局限较多。</p>
<h5 id="缓存延时双删">
  缓存延时双删
  <a class="anchor" href="#%e7%bc%93%e5%ad%98%e5%bb%b6%e6%97%b6%e5%8f%8c%e5%88%a0">#</a>
</h5>
<p>什么是延时双删：</p>
<p>写请求-&gt;删除缓存-&gt;更新数据-&gt;休眠一会-&gt;删除缓存</p>
<p>休眠时间一般为：读业务逻辑数据的耗时 + 几百毫秒</p>
<p>为了确保读请求结束，写请求可以删除读请求可能带来的缓存脏数据。</p>
<h5 id="删除缓存重试机制">
  删除缓存重试机制
  <a class="anchor" href="#%e5%88%a0%e9%99%a4%e7%bc%93%e5%ad%98%e9%87%8d%e8%af%95%e6%9c%ba%e5%88%b6">#</a>
</h5>
<p>对于延时双删、Cache-Aside的先操作数据库再删除缓存都会存在一个问题：在删除缓存时失败了，导致数据库与缓存不一致</p>
<p>为了解决这一个问题，我们可以引入一个失败重试机制，引入消息队列，当第一次删除缓存失败后，将要删除的key加入消息队列中，后续由消息队列消费者执行删除逻辑，直到删除成功。</p>
<p><img src="https://static.jiangliuhong.top/images/2024/2/161708071616412.png" alt="161708071616412.png" /></p>
<p>为保证一致性，这里再添加消息队列的时候，应该使用事务消息，保证消息队列添加与数据库修改在同一个事务中，以此可以进一步保证一致性。</p>
<p>当然，对于消息队列而言，应存在一个失败次数限制，当失败次数达到时，应该通知管理员介入进行处理。</p>
<h5 id="通过binlog异步删除缓存">
  通过binlog异步删除缓存
  <a class="anchor" href="#%e9%80%9a%e8%bf%87binlog%e5%bc%82%e6%ad%a5%e5%88%a0%e9%99%a4%e7%bc%93%e5%ad%98">#</a>
</h5>
<p>对于 MySQL 而言，可以通过数据库的binlog来异步淘汰key。具体的可以使用阿里的canal将binlog日志采集发送到MQ队列里面，然后通过ACK机制确认处理这条更新消息，删除缓存，保证数据缓存一致性。</p>
<p>当然对于其他数据库也有其他相应的插件。</p>
<h2 id="缓存雪崩">
  缓存雪崩
  <a class="anchor" href="#%e7%bc%93%e5%ad%98%e9%9b%aa%e5%b4%a9">#</a>
</h2>
<h3 id="什么是缓存雪崩">
  什么是缓存雪崩
  <a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e7%bc%93%e5%ad%98%e9%9b%aa%e5%b4%a9">#</a>
</h3>
<p>造成缓存雪崩的主要原因有二：</p>
<ol>
<li>大量缓存数据同时过期</li>
<li>redis故障</li>
</ol>
<p>通常我们为了保证缓存中的数据与数据库中的数据一致性，会给 Redis 里的数据设置过期时间，当缓存数据过期后，用户访问的数据如果不在缓存里，业务系统需要重新生成缓存，因此就会访问数据库，并将数据更新到 Redis 里，这样后续请求都可以直接命中缓存。</p>
<p>当大量缓存数据在同一时间过期（失效）或者 Redis 故障宕机时，如果此时有大量的用户请求，都无法在 Redis 中处理，于是全部请求都直接访问数据库，从而导致数据库的压力骤增，严重的会造成数据库宕机，从而形成一系列连锁反应，造成整个系统崩溃，这就是缓存雪崩的问题。</p>
<p><img src="https://static.jiangliuhong.top/images/2024/2/171708146244546.png" alt="171708146244546.png" /></p>
<p>针对<strong>大量缓存数据同时过期</strong>的应对措施是：</p>
<ul>
<li>均匀设置过期时间：给这些数据的过期时间加上一个随机数，这样就保证数据不会在同一时间过期。</li>
<li>增加互斥锁
<ul>
<li>如果发现访问的数据不在 Redis 里，就加个互斥锁，保证同一时间内只有一个请求来构建缓存（从数据库读取数据，再将数据更新到 Redis 里），当缓存构建完成后，再释放锁</li>
<li>未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值</li>
<li>实现互斥锁时应该增加一个超时时间，避免程序一直处于阻塞状态</li>
</ul>
</li>
<li>后台更新缓存：业务线程不再负责更新缓存，缓存也不设置有效期，而是让缓存“永久有效”，并将更新缓存的工作交由后台线程定时更新</li>
</ul>
<p>对于后台更新缓存而言，也存在极大的弊端，当系统内存紧张的时候，有些缓存数据会被“淘汰”，而在缓存被“淘汰”到下一次后台定时更新缓存的这段时间内，业务线程读取缓存失败就返回空值，业务的视角就以为是数据丢失了。</p>
<p>为解决这一弊端的方法有两个：</p>
<ul>
<li>后台线程不仅负责定时更新缓存，而且也负责频繁地检测缓存是否有效，检测到缓存失效了，原因可能是系统紧张而被淘汰的，于是就要马上从数据库读取数据，并更新到缓存。这种方式也存在弊端，那就是检测时间间隔不能太长，太长也导致用户获取的数据是一个空值而不是真正的数据</li>
<li>通过消息队列发送一条消息通知后台线程更新缓存，后台线程收到消息后，在更新缓存前可以判断缓存是否存在，存在就不执行更新缓存操作；不存在就读取数据库数据，并将数据加载到缓存。这种方式相比第一种方式缓存的更新会更及时，用户体验也比较好。</li>
</ul>
<p>针对<strong>redis故障</strong>的常用的解决方法是：</p>
<ul>
<li>服务熔断或请求限流机制</li>
<li>构建 Redis 缓存高可靠集群</li>
</ul>
<p><strong>服务熔断或请求限流机制：</strong> 暂停业务应用对缓存服务的访问，直接返回错误，使得业务线程不在继续访问数据库，从而保障数据库的正常运行。但是直接粗暴处理，会使得业务功能受限，在此可以增加限流机制，只将少部分请求发送到数据库进行处理，再多的请求就在入口直接拒绝服务，等到 Redis 恢复正常并把缓存预热完后，再解除请求限流的机制。</p>
<p><strong>构建 Redis 缓存高可靠集群：</strong> 主从节点的方式构建 Redis 缓存高可靠集群。集群构建参考：<a href="../high/#%e4%b8%bb%e4%bb%8e%e5%a4%8d%e5%88%b6">redis主从复制</a></p>
<h2 id="缓存击穿">
  缓存击穿
  <a class="anchor" href="#%e7%bc%93%e5%ad%98%e5%87%bb%e7%a9%bf">#</a>
</h2>
<p>缓存击穿主要是热点缓存数据过期。对于一个业务系统通常会有一些数据被频繁访问，对于访问频次高的数据称为热点数据。</p>
<p>在一个系统中，如果缓存中的某个热点数据过期了，此时大量的请求访问到该热点数据，就会出现缓存无法提供，所有的请求都直接访问数据库，从而数据库被高并发的请求冲垮，此类问题就被称为缓存击穿问题。</p>
<p><img src="https://static.jiangliuhong.top/images/2024/2/171708174681488.png" alt="171708174681488.png" /></p>
<p>稍稍细心一点，不难发现，缓存击穿与缓存雪崩类似，我们可以将缓存击穿认为是缓存雪崩的一个子集。</p>
<p>所以对于缓存击穿，可以使用缓存雪崩的两种方式去解决：</p>
<ul>
<li>增加互斥锁</li>
<li>后台更新缓存数据</li>
</ul>
<h2 id="缓存穿透">
  缓存穿透
  <a class="anchor" href="#%e7%bc%93%e5%ad%98%e7%a9%bf%e9%80%8f">#</a>
</h2>
<p>当发生缓存雪崩或击穿时，数据库中还是保存了应用要访问的数据，一旦缓存恢复相对应的数据，就可以减轻数据库的压力，而缓存穿透就不一样了。</p>
<p>缓存穿透是<strong>数据既不在缓存也不在数据库</strong></p>
<p>当用户访问的数据，既不在缓存中，也不在数据库中，导致请求在访问缓存时，发现缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据，没办法构建缓存数据，来服务后续的请求。那么当有大量这样的请求到来时，数据库的压力骤增，这就是缓存穿透的问题。</p>
<p><img src="https://static.jiangliuhong.top/images/2024/2/171708175362082.png" alt="171708175362082.png" /></p>
<p>缓存穿透的发生一般有这两种情况：</p>
<ul>
<li>业务误操作，缓存中的数据和数据库中的数据都被误删除了，所以导致缓存和数据库中都没有数据；</li>
<li>黑客恶意攻击，故意大量访问某些读取不存在数据的业务；</li>
</ul>
<p>应对缓存穿透的方案，常见的方案有三种:</p>
<ul>
<li>非法请求的限制:当有大量恶意请求访问不存在的数据的时候，也会发生缓存穿透，因此在 API 入口处我们要判断求请求参数是否合理，请求参数是否含有非法值、请求字段是否存在，如果判断出是恶意请求就直接返回错误，避免进一步访问缓存和数据库。</li>
<li>增加缓存空值或者默认值：针对查询的数据，在缓存中设置一个空值或者默认值，这样后续请求就可以从缓存中读取到空值或者默认值，返回给应用，而不会继续查询数据库。</li>
<li>使用<a href="./#%e5%b8%83%e9%9a%86%e8%bf%87%e6%bb%a4%e5%99%a8">布隆过滤器</a>进行判断：在写入数据库数据时，使用布隆过滤器做个标记，然后在用户请求到来时，业务线程确认缓存失效后，可以通过查询布隆过滤器快速判断数据是否存在，如果不存在，就不用通过查询数据库来判断数据是否存在。即使发生了缓存穿透，大量请求只会查询 Redis 和布隆过滤器，而不会查询数据库，保证了数据库能正常运行，Redis 自身也是支持布隆过滤器的。</li>
</ul>
<p><img src="https://static.jiangliuhong.top/images/2024/2/171708176147710.png" alt="171708176147710.png" /></p>
<h2 id="缓存的并发竞争">
  缓存的并发竞争
  <a class="anchor" href="#%e7%bc%93%e5%ad%98%e7%9a%84%e5%b9%b6%e5%8f%91%e7%ab%9e%e4%ba%89">#</a>
</h2>
<p>缓存的并发竞争指的是多个客户端同时操作同一个key的值，同时进行set操作所引发的并发问题。</p>
<p>解决这一问题的方法也简单，只需要添加一个分布式锁即可，对于redis我们可以直接使用redis的setnx实现分布式锁，具体逻辑为：</p>
<pre tabindex="0"><code>业务逻辑处理
for 1 ... 5 { 限制最多重试 5 次

  获取分布式锁
  if 锁获取成功 {
    操作缓存
    处理业务逻辑
    break
  }
  获取锁失败，休眠一下继续重试
}

如果重试获取锁失败，需要增加失败的逻辑逻辑
</code></pre><p>对于并发较大的分布式系统，我们还可以使用分消息队列来处理这类问题，利用消息队列的顺序消息功能，将对同一个 key 的操作顺序化</p>
<p><img src="https://static.jiangliuhong.top/images/2024/2/181708234316890.png" alt="181708234316890.png" /></p>
<h2 id="布隆过滤器">
  布隆过滤器
  <a class="anchor" href="#%e5%b8%83%e9%9a%86%e8%bf%87%e6%bb%a4%e5%99%a8">#</a>
</h2>
<p>布隆过滤器由「初始值都为 0 的位图数组」和「 N 个哈希函数」两部分组成。当我们在写入数据库数据时，在布隆过滤器里做个标记，这样下次查询数据是否在数据库时，只需要查询布隆过滤器，如果查询到数据没有被标记，说明不在数据库中。</p>
<p>布隆过滤器会通过 3 个操作完成标记：</p>
<ol>
<li>使用 N 个哈希函数分别对数据做哈希计算，得到 N 个哈希值；</li>
<li>将第一步得到的 N 个哈希值对位图数组的长度取模，得到每个哈希值在位图数组的对应位置。</li>
<li>将每个哈希值在位图数组的对应位置的值设置为 1；</li>
</ol>
<p>举个例子，假设有一个位图数组长度为 8，哈希函数 3 个的布隆过滤器。</p>
<p><img src="https://static.jiangliuhong.top/images/2024/2/171708175706690.png" alt="171708175706690.png" /></p>
<p>在数据库写入数据 x 后，把数据 x 标记在布隆过滤器时，数据 x 会被 3 个哈希函数分别计算出 3 个哈希值，然后在对这 3 个哈希值对 8 取模，假设取模的结果为 1、4、6，然后把位图数组的第 1、4、6 位置的值设置为 1。当应用要查询数据 x 是否数据库时，通过布隆过滤器只要查到位图数组的第 1、4、6 位置的值是否全为 1，只要有一个为 0，就认为数据 x 不在数据库中。</p>
<p>布隆过滤器由于是基于哈希函数实现查找的，高效查找的同时存在哈希冲突的可能性，比如数据 x 和数据 y 可能都落在第 1、4、6 位置，而事实上，可能数据库中并不存在数据 y，存在误判的情况。</p>
<p>所以，<strong>查询布隆过滤器说数据存在，并不一定证明数据库中存在这个数据，但是查询到数据不存在，数据库中一定就不存在这个数据</strong></p>
<p>在redis中可以使用<code>bitmaps</code>实现布隆过滤器，通过<code>setbit key offset value</code>(设置值)、<code>getbit key offset</code>(获取值)、<code>bitcount key [start end]</code>(获取位图指定范围值为1的个数)命令可以完成对数据的存储。</p>
<h3 id="redisson实现布隆过滤器">
  Redisson实现布隆过滤器
  <a class="anchor" href="#redisson%e5%ae%9e%e7%8e%b0%e5%b8%83%e9%9a%86%e8%bf%87%e6%bb%a4%e5%99%a8">#</a>
</h3>
<p>在java应用中，可以通过引入<code>Redisson</code>框架很容易的实现布隆过滤器功能，代码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> org.redisson.Redisson;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> org.redisson.api.RBloomFilter;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> org.redisson.api.RedissonClient;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> org.redisson.config.Config;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">RedissonBloomFilter</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args) {
</span></span><span style="display:flex;"><span>        Config config <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Config();
</span></span><span style="display:flex;"><span>        config.<span style="color:#a6e22e">useSingleServer</span>().<span style="color:#a6e22e">setAddress</span>(<span style="color:#e6db74">&#34;redis://127.0.0.1:6379&#34;</span>);
</span></span><span style="display:flex;"><span>        config.<span style="color:#a6e22e">useSingleServer</span>().<span style="color:#a6e22e">setPassword</span>(<span style="color:#e6db74">&#34;123&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//构造Redisson</span>
</span></span><span style="display:flex;"><span>        RedissonClient redisson <span style="color:#f92672">=</span> Redisson.<span style="color:#a6e22e">create</span>(config);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        RBloomFilter<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> bloomFilter <span style="color:#f92672">=</span> redisson.<span style="color:#a6e22e">getBloomFilter</span>(<span style="color:#e6db74">&#34;phoneList&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//初始化布隆过滤器：预计元素为100000000L,误差率为3%</span>
</span></span><span style="display:flex;"><span>        bloomFilter.<span style="color:#a6e22e">tryInit</span>(100000000L,0.<span style="color:#a6e22e">03</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//将号码10086插入到布隆过滤器中</span>
</span></span><span style="display:flex;"><span>        bloomFilter.<span style="color:#a6e22e">add</span>(<span style="color:#e6db74">&#34;10086&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//判断下面号码是否在布隆过滤器中</span>
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(bloomFilter.<span style="color:#a6e22e">contains</span>(<span style="color:#e6db74">&#34;123456&#34;</span>));<span style="color:#75715e">//false</span>
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(bloomFilter.<span style="color:#a6e22e">contains</span>(<span style="color:#e6db74">&#34;10086&#34;</span>));<span style="color:#75715e">//true</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="guava实现布隆过滤器">
  guava实现布隆过滤器
  <a class="anchor" href="#guava%e5%ae%9e%e7%8e%b0%e5%b8%83%e9%9a%86%e8%bf%87%e6%bb%a4%e5%99%a8">#</a>
</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> com.google.common.base.Charsets;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> com.google.common.hash.BloomFilter;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> com.google.common.hash.Funnel;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> com.google.common.hash.Funnels;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">GuavaBloomFilter</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args) {
</span></span><span style="display:flex;"><span>        BloomFilter<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> bloomFilter <span style="color:#f92672">=</span> BloomFilter.<span style="color:#a6e22e">create</span>(Funnels.<span style="color:#a6e22e">stringFunnel</span>(Charsets.<span style="color:#a6e22e">UTF_8</span>),100000,0.<span style="color:#a6e22e">01</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        bloomFilter.<span style="color:#a6e22e">put</span>(<span style="color:#e6db74">&#34;10086&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(bloomFilter.<span style="color:#a6e22e">mightContain</span>(<span style="color:#e6db74">&#34;123456&#34;</span>));
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(bloomFilter.<span style="color:#a6e22e">mightContain</span>(<span style="color:#e6db74">&#34;10086&#34;</span>));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="redis-布隆过滤器插件">
  redis 布隆过滤器插件
  <a class="anchor" href="#redis-%e5%b8%83%e9%9a%86%e8%bf%87%e6%bb%a4%e5%99%a8%e6%8f%92%e4%bb%b6">#</a>
</h3>
<p>redis官方基于<code>bitmaps</code>数据结构实现了布隆过滤器，并提供了官方插件，下载地址为：<a href="https://github.com/RedisLabsModules/rebloom">https://github.com/RedisLabsModules/rebloom</a>（推荐使用redis 6.x+集成）</p>
<p>安装步骤如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e"># 下载插件 </span>
</span></span><span style="display:flex;"><span>wget https://github.com/RedisLabsModules/rebloom/archive/v2.2.6.tar.gz
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 解压</span>
</span></span><span style="display:flex;"><span>tar -zxvf v2.2.6.tar.gz
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 编译插件</span>
</span></span><span style="display:flex;"><span>cd RedisBloom-2.2.6/
</span></span></code></pre></div><p>编译完成后会得到一个<code>redisbloom.so</code>文件，修改redis.conf将这个文件加入到配置文件中</p>
<pre tabindex="0"><code>loadmodule /usr/local/soft/RedisBloom-2.2.6/redisbloom.so
</code></pre><p>最后重启redis即完成插件安装。</p>
<p>插件安装完成后，redis的命令将会得到扩展：</p>
<ul>
<li>bf.add 添加一个元素</li>
<li>bf.exists 判断一个元素是否存在</li>
<li>bf.madd 添加多个元素</li>
<li>bf.mexists 判断多个元素是否存在</li>
</ul>
<p>详细的说明参考：<a href="https://redis.io/docs/data-types/probabilistic/bloom-filter/">https://redis.io/docs/data-types/probabilistic/bloom-filter/</a></p>
<p>如果不想自己安装，也可以使用官方提供的镜像：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>docker run -p 6379:6379 -it --rm redis/redis-stack-server:latest
</span></span></code></pre></div><h2 id="性能调优">
  性能调优
  <a class="anchor" href="#%e6%80%a7%e8%83%bd%e8%b0%83%e4%bc%98">#</a>
</h2>
<p>TODO</p>
<h2 id="spring-集成">
  spring 集成
  <a class="anchor" href="#spring-%e9%9b%86%e6%88%90">#</a>
</h2>
<p>TODO</p>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#缓存场景问题">缓存场景问题</a>
      <ul>
        <li><a href="#双写一致性如何保证">双写一致性如何保证</a>
          <ul>
            <li><a href="#什么一致性">什么一致性</a></li>
            <li><a href="#三个经典缓存模式">三个经典缓存模式</a></li>
            <li><a href="#缓存数据更新">缓存数据更新</a></li>
            <li><a href="#双写情况下是先操作数据库还是缓存">双写情况下，是先操作数据库还是缓存</a></li>
            <li><a href="#保证一致性的一些方法">保证一致性的一些方法</a>
              <ul>
                <li><a href="#同事务强一致性">同事务强一致性</a></li>
                <li><a href="#缓存延时双删">缓存延时双删</a></li>
                <li><a href="#删除缓存重试机制">删除缓存重试机制</a></li>
                <li><a href="#通过binlog异步删除缓存">通过binlog异步删除缓存</a></li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#缓存雪崩">缓存雪崩</a>
      <ul>
        <li><a href="#什么是缓存雪崩">什么是缓存雪崩</a></li>
      </ul>
    </li>
    <li><a href="#缓存击穿">缓存击穿</a></li>
    <li><a href="#缓存穿透">缓存穿透</a></li>
    <li><a href="#缓存的并发竞争">缓存的并发竞争</a></li>
    <li><a href="#布隆过滤器">布隆过滤器</a>
      <ul>
        <li><a href="#redisson实现布隆过滤器">Redisson实现布隆过滤器</a></li>
        <li><a href="#guava实现布隆过滤器">guava实现布隆过滤器</a></li>
        <li><a href="#redis-布隆过滤器插件">redis 布隆过滤器插件</a></li>
      </ul>
    </li>
    <li><a href="#性能调优">性能调优</a></li>
    <li><a href="#spring-集成">spring 集成</a></li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












