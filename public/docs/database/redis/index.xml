<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Redis on 复习吧</title>
    <link>http://localhost:1313/docs/database/redis/</link>
    <description>Recent content in Redis on 复习吧</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 21 Feb 2024 10:48:17 +0800</lastBuildDate>
    <atom:link href="http://localhost:1313/docs/database/redis/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Redis核心知识</title>
      <link>http://localhost:1313/docs/database/redis/core/</link>
      <pubDate>Mon, 19 Feb 2024 11:53:59 +0800</pubDate>
      <guid>http://localhost:1313/docs/database/redis/core/</guid>
      <description>&lt;h1 id=&#34;核心知识&#34;&gt;&#xA;  核心知识&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a0%b8%e5%bf%83%e7%9f%a5%e8%af%86&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;持久化&#34;&gt;&#xA;  持久化&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%8c%81%e4%b9%85%e5%8c%96&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;redis 提供了两种持久化的方式，分别是RDB（Redis DataBase）和AOF（Append Only File）。&lt;/p&gt;&#xA;&lt;p&gt;RDB，简而言之，就是在不同的时间点，将 redis 存储的数据生成快照并存储到磁盘等介质上；&lt;/p&gt;&#xA;&lt;p&gt;AOF，则是换了一个角度来实现持久化，那就是将 redis 执行过的所有写指令记录下来，在下次 redis 重新启动时，只要把这些写指令从前到后再重复执行一遍，就可以实现数据恢复了。&lt;/p&gt;&#xA;&lt;p&gt;其实 RDB 和 AOF 两种方式也可以同时使用，在这种情况下，如果 redis 重启的话，则会优先采用 AOF 方式来进行数据恢复，这是因为 AOF 方式的数据恢复完整度更高。&lt;/p&gt;&#xA;&lt;p&gt;如果你没有数据持久化的需求，也完全可以关闭 RDB 和 AOF 方式，这样的话，redis 将变成一个纯内存数据库，就像 memcache 一样。&lt;/p&gt;&#xA;&lt;h3 id=&#34;rdb&#34;&gt;&#xA;  RDB&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#rdb&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;RDB 是将redis的某一时刻的数据持久化到磁盘中，是一种快照式的持久化方法。&lt;/p&gt;&#xA;&lt;p&gt;redis在进行数据持久化的过程中，会先将数据写入到一个临时文件中，待持久化过程完成，才会将此文件替换为最终的持久化文件。&lt;/p&gt;&#xA;&lt;p&gt;对于 RDB 模式，redis会单独创建一个子进程进行持久化操作，不会有主进程介入，从而保证redis的性能。&lt;/p&gt;&#xA;&lt;p&gt;如果需要进行大规模的数据存储与恢复，那么 RDB 方式是当仁不让的，不过 RDB 的缺点也较为明显：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在redis中，RDB 是默认开启的，默认为每 900 秒内1 次修改、300 秒内 10 此修改、60 秒内 10000次修改进行一次 RDB 备份操作（可以通过&lt;code&gt;save 900 1&lt;/code&gt;的方式修改频率），当redis故障时，根据备份的时间点，总会可能存在数据的丢失。&lt;/li&gt;&#xA;&lt;li&gt;save 频率较高时，频繁写入磁盘，会造成磁盘压力过大，同时多个子进程之间相互竞争服务器 CPU、磁盘资源。&lt;/li&gt;&#xA;&lt;li&gt;虽然 RDB 备份是通过子进程实现，但如果频繁主进程创建子进程进行操作，也会对主进程造成阻塞。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;aof&#34;&gt;&#xA;  AOF&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#aof&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;上面提到 RDB 模式不可避免会存在数据丢失的情况，对于解决这一问题，可以使用 AOF 备份方式，AOF 是将redis执行过程的指令都记录下来，在数据恢复时，按照从前到后的顺序再将指令执行一次。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Redis数据结构</title>
      <link>http://localhost:1313/docs/database/redis/data/</link>
      <pubDate>Sun, 18 Feb 2024 11:53:59 +0800</pubDate>
      <guid>http://localhost:1313/docs/database/redis/data/</guid>
      <description>&lt;h1 id=&#34;数据结构&#34;&gt;&#xA;  数据结构&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;数据类型&#34;&gt;&#xA;  数据类型&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;5种基本类型&#34;&gt;&#xA;  5种基本类型&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#5%e7%a7%8d%e5%9f%ba%e6%9c%ac%e7%b1%bb%e5%9e%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;5 种常见的基本类型有：String、List、Set、Zset、Hash&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;类型&lt;/th&gt;&#xA;          &lt;th&gt;存储的值&lt;/th&gt;&#xA;          &lt;th&gt;读写能力&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;String&lt;/td&gt;&#xA;          &lt;td&gt;字符串、整数或浮点数&lt;/td&gt;&#xA;          &lt;td&gt;对整个字符串或字符串的一部分进行操作；对整数或者浮点数进行自增或自减操作&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;List&lt;/td&gt;&#xA;          &lt;td&gt;链表，链表每个节点都是一个字符串&lt;/td&gt;&#xA;          &lt;td&gt;对链表的两端进行push和pop操作，读取单个或者多个元素；根据值查找或删除元素&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Set&lt;/td&gt;&#xA;          &lt;td&gt;字符串的无序集合&lt;/td&gt;&#xA;          &lt;td&gt;字符串的集合，基础操作有添加、删除、获取；同时还有计算交集、并集、差集等&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Hash&lt;/td&gt;&#xA;          &lt;td&gt;包含键值对的无序散列表&lt;/td&gt;&#xA;          &lt;td&gt;基本方法有添加、获取、删除单个元素方法&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Zset&lt;/td&gt;&#xA;          &lt;td&gt;与Hash相同，用于存储键值对&lt;/td&gt;&#xA;          &lt;td&gt;字符串成员与浮点数之间的有序映射，元素的排列顺序由分数的大小决定；基本方法有添加、获取、删除单个元素以及根据分数范围或成员来获取元素&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h4 id=&#34;string&#34;&gt;&#xA;  String&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#string&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;p&gt;String是redis中最基本的数据类型，一个key对应一个value。&lt;/p&gt;&#xA;&lt;p&gt;String类型是二进制安全的，意思是 redis 的 string 可以包含任何数据。如数字，字符串，jpg图片或者序列化的对象。&lt;/p&gt;&#xA;&lt;p&gt;String类型的常用操作有：&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;命令&lt;/th&gt;&#xA;          &lt;th&gt;简述&lt;/th&gt;&#xA;          &lt;th&gt;使用&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;GET&lt;/td&gt;&#xA;          &lt;td&gt;获取存储在给定键中的值&lt;/td&gt;&#xA;          &lt;td&gt;GET name&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;SET&lt;/td&gt;&#xA;          &lt;td&gt;设置存储在给定键中的值&lt;/td&gt;&#xA;          &lt;td&gt;SET name value&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;DEL&lt;/td&gt;&#xA;          &lt;td&gt;删除存储在给定键中的值&lt;/td&gt;&#xA;          &lt;td&gt;DEL name&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;INCR&lt;/td&gt;&#xA;          &lt;td&gt;将键存储的值加1&lt;/td&gt;&#xA;          &lt;td&gt;INCR key&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;DECR&lt;/td&gt;&#xA;          &lt;td&gt;将键存储的值减1&lt;/td&gt;&#xA;          &lt;td&gt;DECR key&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;INCRBY&lt;/td&gt;&#xA;          &lt;td&gt;将键存储的值加上整数&lt;/td&gt;&#xA;          &lt;td&gt;INCRBY key amount&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;DECRBY&lt;/td&gt;&#xA;          &lt;td&gt;将键存储的值减去整数&lt;/td&gt;&#xA;          &lt;td&gt;DECRBY key amount&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;更加详细的string操作参考：&lt;a href=&#34;https://www.redis.net.cn/order/3544.html&#34;&gt;https://www.redis.net.cn/order/3544.html&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Redis高可用</title>
      <link>http://localhost:1313/docs/database/redis/high/</link>
      <pubDate>Sat, 17 Feb 2024 11:53:59 +0800</pubDate>
      <guid>http://localhost:1313/docs/database/redis/high/</guid>
      <description>&lt;h1 id=&#34;高可用&#34;&gt;&#xA;  高可用&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%ab%98%e5%8f%af%e7%94%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;主从复制&#34;&gt;&#xA;  主从复制&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%bb%e4%bb%8e%e5%a4%8d%e5%88%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;TODO&lt;/p&gt;&#xA;&lt;h2 id=&#34;哨兵模式&#34;&gt;&#xA;  哨兵模式&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%93%a8%e5%85%b5%e6%a8%a1%e5%bc%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;TODO&lt;/p&gt;&#xA;&lt;h2 id=&#34;分片技术&#34;&gt;&#xA;  分片技术&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%86%e7%89%87%e6%8a%80%e6%9c%af&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;TODO&lt;/p&gt;</description>
    </item>
    <item>
      <title>Redis应用实践</title>
      <link>http://localhost:1313/docs/database/redis/apply/</link>
      <pubDate>Fri, 16 Feb 2024 11:53:59 +0800</pubDate>
      <guid>http://localhost:1313/docs/database/redis/apply/</guid>
      <description>&lt;h1 id=&#34;应用实践&#34;&gt;&#xA;  应用实践&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%ba%94%e7%94%a8%e5%ae%9e%e8%b7%b5&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;缓存场景问题&#34;&gt;&#xA;  缓存场景问题&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%bc%93%e5%ad%98%e5%9c%ba%e6%99%af%e9%97%ae%e9%a2%98&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;常见的redis问题主要有：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;缓存和数据库双写一致性问题&lt;/li&gt;&#xA;&lt;li&gt;缓存雪崩问题&lt;/li&gt;&#xA;&lt;li&gt;缓存击穿问题&lt;/li&gt;&#xA;&lt;li&gt;缓存穿透问题&lt;/li&gt;&#xA;&lt;li&gt;缓存的并发竞争问题&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;双写一致性如何保证&#34;&gt;&#xA;  双写一致性如何保证&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8f%8c%e5%86%99%e4%b8%80%e8%87%b4%e6%80%a7%e5%a6%82%e4%bd%95%e4%bf%9d%e8%af%81&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h4 id=&#34;什么一致性&#34;&gt;&#xA;  什么一致性&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%80%e4%b9%88%e4%b8%80%e8%87%b4%e6%80%a7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;p&gt;首先是一致性问题，在分布式系统中，可以理解为多个节点中数据的值是一致的。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;强一致性：这种一致性级别是最符合用户直觉的，它要求系统写入什么，读出来的也会是什么，用户体验好，但实现起来往往对系统的性能影响大&lt;/li&gt;&#xA;&lt;li&gt;弱一致性：这种一致性级别约束了系统在写入成功后，不承诺立即可以读到写入的值，也不承诺多久之后数据能够达到一致，但会尽可能地保证到某个时间级别（比如秒级别）后，数据能够达到一致状态&lt;/li&gt;&#xA;&lt;li&gt;最终一致性：最终一致性是弱一致性的一个特例，系统会保证在一定时间内，能够达到一个数据一致的状态。这里之所以将最终一致性单独提出来，是因为它是弱一致性中非常推崇的一种一致性模型，也是业界在大型分布式系统的数据一致性上比较推崇的模型&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;三个经典缓存模式&#34;&gt;&#xA;  三个经典缓存模式&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%89%e4%b8%aa%e7%bb%8f%e5%85%b8%e7%bc%93%e5%ad%98%e6%a8%a1%e5%bc%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;p&gt;缓存可以提升性能、缓解数据库压力，但是使用缓存也会导致数据不一致性的问题。一般使用缓存的方式有三种：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Cache-Aside Pattern，旁路缓存模式，主要特点为：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;读的时候，先读缓存，缓存命中的话，直接返回数据&lt;/li&gt;&#xA;&lt;li&gt;缓存没有命中的话，就去读数据库，从数据库取出数据，放入缓存后，同时返回响应。&lt;/li&gt;&#xA;&lt;li&gt;更新时先更新数据库，然后再删除缓存&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Read-Through/Write through，读写穿透模式，服务端把缓存作为主要数据存储。应用程序跟数据库缓存交互，都是通过抽象缓存层完成的。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;从缓存读取数据，读到直接返回&lt;/li&gt;&#xA;&lt;li&gt;如果读取不到的话，从数据库加载，写入缓存后，再返回响应。&lt;/li&gt;&#xA;&lt;li&gt;与Cache-Aside相似，仅是在它之上增加了一个抽象层&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Write behind，异步缓存写入模式&#xA;&lt;ul&gt;&#xA;&lt;li&gt;与Read-Through/Write-Through类似，都有一个抽象层负责缓存和数据库的读写&lt;/li&gt;&#xA;&lt;li&gt;不同的是，Write Behind只负责更新缓存，不直接对数据库进行操作，他通过异步的批量操作的方式去更新数据库&lt;/li&gt;&#xA;&lt;li&gt;这种方式下，缓存和数据库的一致性不强，对一致性要求高的系统要谨慎使用&lt;/li&gt;&#xA;&lt;li&gt;适合频繁写的场景，MySQL的InnoDB Buffer Pool机制就使用到这种模式。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;缓存数据更新&#34;&gt;&#xA;  缓存数据更新&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%bc%93%e5%ad%98%e6%95%b0%e6%8d%ae%e6%9b%b4%e6%96%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;p&gt;在操作缓存的时候，是应该去更新缓存，还是删除后重建？&lt;/p&gt;&#xA;&lt;p&gt;一般情况下，我们是删除缓存，再下次读取时，获取到数据库数据后再新建缓存数据。&lt;/p&gt;&#xA;&lt;p&gt;对于这两种的选择的情况一般如下&lt;/p&gt;&#xA;&lt;p&gt;删除缓存的场景：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;写入场景较多（当然写的场景较多的情况下，也需要考虑是否需要引入缓存）&lt;/li&gt;&#xA;&lt;li&gt;缓存计算逻辑复杂&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;更新缓存的场景：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;写数据库较少&lt;/li&gt;&#xA;&lt;li&gt;更新频率低&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;双写情况下是先操作数据库还是缓存&#34;&gt;&#xA;  双写情况下，是先操作数据库还是缓存&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8f%8c%e5%86%99%e6%83%85%e5%86%b5%e4%b8%8b%e6%98%af%e5%85%88%e6%93%8d%e4%bd%9c%e6%95%b0%e6%8d%ae%e5%ba%93%e8%bf%98%e6%98%af%e7%bc%93%e5%ad%98&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;p&gt;Cache-Aside缓存模式中，在写入请求的时候，为什么是先操作数据库呢？为什么不先操作缓存呢？&lt;/p&gt;&#xA;&lt;p&gt;由于使用的是删除缓存的方式，如果是先操作缓存再操作数据库，此时两个线程并发读写，就会可能出现缓存中的数据与数据库数据不一致的问题。&lt;/p&gt;&#xA;&lt;h4 id=&#34;保证一致性的一些方法&#34;&gt;&#xA;  保证一致性的一些方法&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bf%9d%e8%af%81%e4%b8%80%e8%87%b4%e6%80%a7%e7%9a%84%e4%b8%80%e4%ba%9b%e6%96%b9%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;h5 id=&#34;同事务强一致性&#34;&gt;&#xA;  同事务强一致性&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%90%8c%e4%ba%8b%e5%8a%a1%e5%bc%ba%e4%b8%80%e8%87%b4%e6%80%a7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h5&gt;&#xA;&lt;p&gt;对于非分布式系统而言，我们可以使数据库操作与redis操作在同一个事务中，具体流程是：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;开启事务&lt;/li&gt;&#xA;&lt;li&gt;修改数据库&lt;/li&gt;&#xA;&lt;li&gt;执行redis命令&lt;/li&gt;&#xA;&lt;li&gt;提交事务&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;基于这种方式，可以保证数据库被修改，缓存一定被删除，但这种方式局限较多。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Redis基础概念</title>
      <link>http://localhost:1313/docs/database/redis/base/</link>
      <pubDate>Wed, 14 Feb 2024 11:53:59 +0800</pubDate>
      <guid>http://localhost:1313/docs/database/redis/base/</guid>
      <description>&lt;h1 id=&#34;redis基础概念&#34;&gt;&#xA;  Redis基础概念&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#redis%e5%9f%ba%e7%a1%80%e6%a6%82%e5%bf%b5&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;p&gt;Redis是一款内存高速缓存数据库。Redis全称为：Remote Dictionary Server（远程数据服务），使用C语言编写，Redis是一个key-value存储系统（键值存储系统），支持丰富的数据类型，如：String、list、set、zset、hash。Redis是一种支持key-value等多种数据结构的存储系统。可用于缓存，事件发布或订阅，高速队列等场景。支持网络，提供字符串，哈希，列表，队列，集合结构直接存取，基于内存，可持久化。&lt;/p&gt;&#xA;&lt;h2 id=&#34;为什么要使用redis&#34;&gt;&#xA;  为什么要使用redis&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e4%bd%bf%e7%94%a8redis&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;使用redis主要基于其&lt;strong&gt;性能&lt;/strong&gt;与&lt;strong&gt;并发&lt;/strong&gt;的特点。&lt;/p&gt;&#xA;&lt;p&gt;比如一个执行耗时久并且结果变动不频繁的SQL，可以尝试将结果放到缓存中，使得请求可以快速响应。&lt;/p&gt;&#xA;&lt;p&gt;再比如一个并发很大的功能，如果每次都从数据库获取数据，由于数据库响应问题，可能会出现连接异常，照成响应失败，这时可以将数据放在redis种，提高响应速度，降低数据库压力。&lt;/p&gt;&#xA;&lt;p&gt;当然，redis除了性能与并发，也存在其他特点，现将这些特点总结如下：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;读写性能优异：Redis能读的速度是110000次/s,写的速度是81000次/s&lt;/li&gt;&#xA;&lt;li&gt;数据类型丰富：Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作&lt;/li&gt;&#xA;&lt;li&gt;原子性：Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行&lt;/li&gt;&#xA;&lt;li&gt;发布订阅：Redis支持发布/订阅模式&lt;/li&gt;&#xA;&lt;li&gt;持久化：Redis支持RDB, AOF等持久化方式&lt;/li&gt;&#xA;&lt;li&gt;支持分布式部署&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;redis为什么响应快&#34;&gt;&#xA;  redis为什么响应快&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#redis%e4%b8%ba%e4%bb%80%e4%b9%88%e5%93%8d%e5%ba%94%e5%bf%ab&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;redis响应快的主要因素有：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;redis是基于内存的，读写都在内存中进行&lt;/li&gt;&#xA;&lt;li&gt;redis是单线程的，不存在上下文切换线程&lt;/li&gt;&#xA;&lt;li&gt;redis采用多路复用IO,可以处理并发连接&lt;/li&gt;&#xA;&lt;li&gt;非阻塞IO内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间。&lt;/li&gt;&#xA;&lt;li&gt;数据结构优化，redis为key-value的存储，使用hash结构，读写速度快；对于特殊的数据类型也引入了特殊的数据结构进行优化，比如使用跳表加快有序的数据结构(比如zset)的读取速度&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;redis为什么是单线程&#34;&gt;&#xA;  redis为什么是单线程&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#redis%e4%b8%ba%e4%bb%80%e4%b9%88%e6%98%af%e5%8d%95%e7%ba%bf%e7%a8%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;不需要各种锁的性能消耗&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;redis的数据结构并不全是简单的Key-Value，还有list，hash等复杂的结构，这些结构有可能会进行很细粒度的操作，比如在很长的列表后面添加一个元素，在hash当中添加或者删除&#xA;一个对象。这些操作可能就需要加非常多的锁，导致的结果是同步开销大大增加。&lt;/p&gt;&#xA;&lt;p&gt;总之，在单线程的情况下，就不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗。&lt;/p&gt;&#xA;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;单线程多进程集群方案&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;单线程的威力实际上非常强大，每核心效率也非常高，多线程自然是可以比单线程有更高的性能上限，但是在今天的计算环境中，即使是单机多线程的上限也往往不能满足需要了，需要进一步摸索的是多服务器集群化的方案，这些方案中多线程的技术照样是用不上的。&lt;/p&gt;&#xA;&lt;p&gt;所以单线程、多进程的集群不失为一个时髦的解决方案。&lt;/p&gt;&#xA;&lt;ol start=&#34;3&#34;&gt;&#xA;&lt;li&gt;CPU消耗&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU。但是如果CPU成为Redis瓶颈，或者不想让服务器其他CUP核闲置，那怎么办?可以考虑多起几个Redis进程，Redis是key-value数据库，不是关系数据库，数据之间没有约束。只要客户端分清哪些key放在哪个Redis进程上就可以了。&lt;/p&gt;&#xA;&lt;h3 id=&#34;什么是多路复用-io&#34;&gt;&#xA;  什么是多路复用 IO&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%80%e4%b9%88%e6%98%af%e5%a4%9a%e8%b7%af%e5%a4%8d%e7%94%a8-io&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;Redis单线程的优劣势单进程单线程优势代码更清晰，处理逻辑更简单不用去考虑各种锁的问题，不存在加锁释放锁操作，不会因为可能出现死锁而导致的性能消耗，不存在多进程或者多线程导致的切换而消耗CPU&lt;/p&gt;&#xA;&lt;p&gt;不过在单线程下无法发挥多核CPU性能，于是redis引入多路复用 IO 方案来保证多连接时的系统吞吐量。&lt;/p&gt;&#xA;&lt;p&gt;其中：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;多路：指的是多个socket连接，即多个网络连接&lt;/li&gt;&#xA;&lt;li&gt;复用：指的是复用一个线程&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;多路复用主要有三种技术：select，poll，epoll。redi采用的是epoll。&lt;/p&gt;&#xA;&lt;p&gt;采用多路 IO 复用技术可以让单个线程高效的处理多个连接请求(尽量减少网络IO的时间消耗)，且Redis在内存中操作数据的速度非常快(内存内的操作不会成为这里的性能瓶颈)，主要以上两点造就了Redis具有很高的吞吐量。&lt;/p&gt;&#xA;&lt;p&gt;在redis中，所有的接收到的请求，都会由单线程来处理（多路复用 IO），而这个单线程并不会立即处理，而是所有的命令都会进入一个 Socket 队列中，当 socket 可读则交给单线程事件分发器逐个被执行。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
