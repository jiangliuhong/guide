<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="
  数据结构
  #


  二叉树
  #


  红黑树
  #


  
  #


  压缩列表(ziplist)
  #

ziplist是一个经过特殊编码的双向链表，它的设计目标是节省内存。它可以存储字符串或者整数。其中整数是按二进制进行编码的，而不是字符串序列。
它能以O(1)的时间复杂度在列表的两端进行push和pop操作。但是由于每个操作都 u 要对ziplist所使用的内存进行重新分配，所以实际操作的复杂度与ziplist占用的内存大小有关。
在redis中，有序集合、散列和列表都直接或间接使用了压缩列表。当有序集合或散列的元素个数较少，并且元素都是短字符串时，redis便会使用压缩列表作为底层数据存储。redis的列表使用的快速链表数据结构进行存储，而快速链表就是双向链表与压缩列表的组合。
总的来说，ziplist有如下特性：

本质上是一个字节数组
是redis为了节约内存而设计的一种线性结构
可以包含多个元素，每个元素可以是一个字节数组或一个整数

在redis中，压缩列表主要由 5 部分组成：

  
      
          属性
          类型
          长度
          用途
      
  
  
      
          zlbytes
          unit32_t
          4字节
          记录整个压缩列表占用的内存字节数：在对压缩列表进行内存重分配，或者计算 zlend 的位置时使用。
      
      
          zltail
          unit32_t
          4字节
          记录压缩列表表尾节点距离压缩列表的起始地址有多少字节：通过这个偏移量，程序无需遍历整个压缩列表就可以确定表尾节点的地址。
      
      
          zllen
          unit16_t
          2字节
          记录了压缩列表包含的节点数量，当这个属性的值小于 UINT16_MAX（65535）时，这个属性的值就是压缩列表包含节点的数量；当这个值等于 UINT16_MAX 时，节点的真实数量需要遍历整个压缩列表才能计算得出。
      
      
          entry
          列表节点
          不定
          压缩列表包含的各个节点
      
      
          zlend
          unit8_t
          1字节
          特殊值 0xFF（十进制 255），用于标记压缩列表的末端。
      
  


如上图所示，这是一个包含三个节点的压缩列表的示例：

zlbytes 属性的值为 0x50（十进制 80），表示压缩列表的总长为 80 字节。
zltail 属性的值为 0x3c（十进制 60），这表示如果我们有一个指向压缩列表起始地址的指针 p，那么只要用指针 p 加上偏移量 60，就可以计算出表尾节点 entry3 的地址。
zllen 属性的值为 0x3（十进制 3），表示压缩列表包含三个节点。

对于压缩列表而言，每个entry的数据结构又包含三部分，分别是：">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:url" content="http://localhost:1313/docs/arithmetic/data/">
  <meta property="og:site_name" content="复习吧">
  <meta property="og:title" content="数据结构">
  <meta property="og:description" content="数据结构 # 二叉树 # 红黑树 # # 压缩列表(ziplist) # ziplist是一个经过特殊编码的双向链表，它的设计目标是节省内存。它可以存储字符串或者整数。其中整数是按二进制进行编码的，而不是字符串序列。
它能以O(1)的时间复杂度在列表的两端进行push和pop操作。但是由于每个操作都 u 要对ziplist所使用的内存进行重新分配，所以实际操作的复杂度与ziplist占用的内存大小有关。
在redis中，有序集合、散列和列表都直接或间接使用了压缩列表。当有序集合或散列的元素个数较少，并且元素都是短字符串时，redis便会使用压缩列表作为底层数据存储。redis的列表使用的快速链表数据结构进行存储，而快速链表就是双向链表与压缩列表的组合。
总的来说，ziplist有如下特性：
本质上是一个字节数组 是redis为了节约内存而设计的一种线性结构 可以包含多个元素，每个元素可以是一个字节数组或一个整数 在redis中，压缩列表主要由 5 部分组成：
属性 类型 长度 用途 zlbytes unit32_t 4字节 记录整个压缩列表占用的内存字节数：在对压缩列表进行内存重分配，或者计算 zlend 的位置时使用。 zltail unit32_t 4字节 记录压缩列表表尾节点距离压缩列表的起始地址有多少字节：通过这个偏移量，程序无需遍历整个压缩列表就可以确定表尾节点的地址。 zllen unit16_t 2字节 记录了压缩列表包含的节点数量，当这个属性的值小于 UINT16_MAX（65535）时，这个属性的值就是压缩列表包含节点的数量；当这个值等于 UINT16_MAX 时，节点的真实数量需要遍历整个压缩列表才能计算得出。 entry 列表节点 不定 压缩列表包含的各个节点 zlend unit8_t 1字节 特殊值 0xFF（十进制 255），用于标记压缩列表的末端。 如上图所示，这是一个包含三个节点的压缩列表的示例：
zlbytes 属性的值为 0x50（十进制 80），表示压缩列表的总长为 80 字节。 zltail 属性的值为 0x3c（十进制 60），这表示如果我们有一个指向压缩列表起始地址的指针 p，那么只要用指针 p 加上偏移量 60，就可以计算出表尾节点 entry3 的地址。 zllen 属性的值为 0x3（十进制 3），表示压缩列表包含三个节点。 对于压缩列表而言，每个entry的数据结构又包含三部分，分别是：">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="docs">
    <meta property="article:published_time" content="2024-02-18T11:53:59+08:00">
    <meta property="article:modified_time" content="2024-02-19T13:43:57+08:00">
<title>数据结构 | 复习吧</title>
<link rel="manifest" href="/manifest.json">
<link rel="icon" href="/favicon.png" >
<link rel="stylesheet" href="/book.min.cdf2dd29f013b9b416743e9529e3db831a1462598e2803454998241de8e37466.css" integrity="sha256-zfLdKfATubQWdD6VKePbgxoUYlmOKANFSZgkHejjdGY=" crossorigin="anonymous">
  <script defer src="/flexsearch.min.js"></script>
  <script defer src="/en.search.min.80ca7f71d8159d5795f243152f289067a8e79866a78fb2aad41736a324b0b3da.js" integrity="sha256-gMp/cdgVnVeV8kMVLyiQZ6jnmGanj7Kq1Bc2oySws9o=" crossorigin="anonymous"></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><span>复习吧</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>












  <ul>
<li>数据库
<ul>
<li><a href="/docs/database/mysql/">MySQL</a>
<ul>
<li><a href="/docs/database/mysql/indexes/">索引</a></li>
<li><a href="/docs/database/mysql/trans/">事务</a></li>
<li><a href="/docs/database/mysql/storage/">数据存储</a></li>
<li><a href="/docs/database/mysql/cluster/">集群</a></li>
<li><a href="/docs/database/mysql/normal/">常见面试题</a></li>
</ul>
</li>
<li>NOSQL 数据库
<ul>
<li><a href="/docs/database/redis/">Redis</a>
<ul>
<li><a href="/docs/database/redis/base/">基础概念</a></li>
<li><a href="/docs/database/redis/data/">数据结构</a></li>
<li><a href="/docs/database/redis/high/">高可用</a></li>
<li><a href="/docs/database/redis/apply/">应用实践</a></li>
</ul>
</li>
<li><a href="/docs/database/es/">ElastiSearch</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="/docs/java/">Java</a></li>
<li>算法
<ul>
<li><a href="/docs/arithmetic/data/"class=active>数据结构</a></li>
</ul>
</li>
<li>中间件
<ul>
<li><a href="/docs/middleware/messagequeue/">消息队列</a></li>
</ul>
</li>
</ul>










</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>数据结构</strong>

  <label for="toc-control">
    
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#二叉树">二叉树</a>
      <ul>
        <li><a href="#红黑树">红黑树</a></li>
        <li></li>
      </ul>
    </li>
    <li><a href="#压缩列表ziplist">压缩列表(ziplist)</a></li>
    <li><a href="#跳跃表zskiplist">跳跃表(zSkiplist)</a>
      <ul>
        <li><a href="#用java实现跳表">用java实现跳表</a></li>
        <li><a href="#redis跳表的实现">redis跳表的实现</a></li>
      </ul>
    </li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown"><h1 id="数据结构">
  数据结构
  <a class="anchor" href="#%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84">#</a>
</h1>
<h2 id="二叉树">
  二叉树
  <a class="anchor" href="#%e4%ba%8c%e5%8f%89%e6%a0%91">#</a>
</h2>
<h3 id="红黑树">
  红黑树
  <a class="anchor" href="#%e7%ba%a2%e9%bb%91%e6%a0%91">#</a>
</h3>
<h3 id="">
  
  <a class="anchor" href="#">#</a>
</h3>
<h2 id="压缩列表ziplist">
  压缩列表(ziplist)
  <a class="anchor" href="#%e5%8e%8b%e7%bc%a9%e5%88%97%e8%a1%a8ziplist">#</a>
</h2>
<p>ziplist是一个经过特殊编码的双向链表，它的设计目标是节省内存。它可以存储字符串或者整数。其中整数是按二进制进行编码的，而不是字符串序列。</p>
<p>它能以O(1)的时间复杂度在列表的两端进行push和pop操作。但是由于每个操作都 u 要对ziplist所使用的内存进行重新分配，所以实际操作的复杂度与ziplist占用的内存大小有关。</p>
<p>在redis中，有序集合、散列和列表都直接或间接使用了压缩列表。当有序集合或散列的元素个数较少，并且元素都是短字符串时，redis便会使用压缩列表作为底层数据存储。redis的列表使用的快速链表数据结构进行存储，而快速链表就是双向链表与压缩列表的组合。</p>
<p>总的来说，ziplist有如下特性：</p>
<ul>
<li>本质上是一个字节数组</li>
<li>是redis为了节约内存而设计的一种线性结构</li>
<li>可以包含多个元素，每个元素可以是一个字节数组或一个整数</li>
</ul>
<p>在redis中，压缩列表主要由 5 部分组成：</p>
<table>
  <thead>
      <tr>
          <th>属性</th>
          <th>类型</th>
          <th>长度</th>
          <th>用途</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>zlbytes</td>
          <td>unit32_t</td>
          <td>4字节</td>
          <td>记录整个压缩列表占用的内存字节数：在对压缩列表进行内存重分配，或者计算 zlend 的位置时使用。</td>
      </tr>
      <tr>
          <td>zltail</td>
          <td>unit32_t</td>
          <td>4字节</td>
          <td>记录压缩列表表尾节点距离压缩列表的起始地址有多少字节：通过这个偏移量，程序无需遍历整个压缩列表就可以确定表尾节点的地址。</td>
      </tr>
      <tr>
          <td>zllen</td>
          <td>unit16_t</td>
          <td>2字节</td>
          <td>记录了压缩列表包含的节点数量，当这个属性的值小于 UINT16_MAX（65535）时，这个属性的值就是压缩列表包含节点的数量；当这个值等于 UINT16_MAX 时，节点的真实数量需要遍历整个压缩列表才能计算得出。</td>
      </tr>
      <tr>
          <td>entry</td>
          <td>列表节点</td>
          <td>不定</td>
          <td>压缩列表包含的各个节点</td>
      </tr>
      <tr>
          <td>zlend</td>
          <td>unit8_t</td>
          <td>1字节</td>
          <td>特殊值 0xFF（十进制 255），用于标记压缩列表的末端。</td>
      </tr>
  </tbody>
</table>
<p><img src="https://static.jiangliuhong.top/images/2024/2/191708309348283.png" alt="191708309348283.png" /></p>
<p>如上图所示，这是一个包含三个节点的压缩列表的示例：</p>
<ul>
<li>zlbytes 属性的值为 0x50（十进制 80），表示压缩列表的总长为 80 字节。</li>
<li>zltail 属性的值为 0x3c（十进制 60），这表示如果我们有一个指向压缩列表起始地址的指针 p，那么只要用指针 p 加上偏移量 60，就可以计算出表尾节点 entry3 的地址。</li>
<li>zllen 属性的值为 0x3（十进制 3），表示压缩列表包含三个节点。</li>
</ul>
<p>对于压缩列表而言，每个entry的数据结构又包含三部分，分别是：</p>
<ul>
<li>previous_entry_length:表示前一个元素的长度，占 1 字节或者 5 字节
<ul>
<li>当前一个元素的长度小于 254 字节时，使用 1 字节表示记录上一个元素长度</li>
<li>当前一个元素的长度大于或等于 254 字节时，用 5 字节表示。其中第一个字节固定为0xFE(十进制为 254)，后 4 字节才是上一个元素的真正长度</li>
</ul>
</li>
<li>encoding：当前元素的编码，记录节点的content字段锁保存的数据的类型以及长度，它的类型一共有两种，分别是字节数组和整数。它的长度可能为 1字节、2 字节或者 5 字节</li>
<li>content：用于保存当前节点的内容，节点内容类型和长度由encoding决定</li>
</ul>
<p><strong>encoding内容说明</strong></p>
<p>当content要存储的数据是字节数组时:</p>
<table>
  <thead>
      <tr>
          <th>内容</th>
          <th>长度</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>00 bbbbbb</td>
          <td>1字节</td>
          <td>最大长度为 63 的字节数组</td>
      </tr>
      <tr>
          <td>01 bbbbbb xxxxxxxx</td>
          <td>2字节｜最大长度 2^14-1的字节数组</td>
          <td></td>
      </tr>
      <tr>
          <td>10 ________ aaaaaaaa bbbbbbbb cccccccc dddddddd</td>
          <td>5字节</td>
          <td>最大长度2^32-1的字节数组</td>
      </tr>
  </tbody>
</table>
<p>当content要存储的数据是整数时：</p>
<table>
  <thead>
      <tr>
          <th>内容</th>
          <th>长度</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>11000000</td>
          <td>1字节</td>
          <td>int16_t类型整数(2字节)</td>
      </tr>
      <tr>
          <td>11010000</td>
          <td>1字节</td>
          <td>int32_t类型整数(4字节)</td>
      </tr>
      <tr>
          <td>11100000</td>
          <td>1字节</td>
          <td>int64_t类型整数(8字节)</td>
      </tr>
      <tr>
          <td>11110000</td>
          <td>1字节</td>
          <td>24位有符号整数(3字节)</td>
      </tr>
      <tr>
          <td>11111110</td>
          <td>1字节</td>
          <td>8 位有符号整数(1字节)</td>
      </tr>
      <tr>
          <td>1111xxxx</td>
          <td>1字节</td>
          <td>用xxxx思维表示内容，此时将不在需要content</td>
      </tr>
      <tr>
          <td>11111111</td>
          <td>1字节</td>
          <td>表示压缩列表的结束</td>
      </tr>
  </tbody>
</table>
<h2 id="跳跃表zskiplist">
  跳跃表(zSkiplist)
  <a class="anchor" href="#%e8%b7%b3%e8%b7%83%e8%a1%a8zskiplist">#</a>
</h2>
<p>跳跃表即跳表，是一个可以快速查询有序连续元素的数据链表。跳表的平均查找和插入时间复杂度都是O(long n)，优于普通队列的O(n)。</p>
<p>它最大的优势是原理简单、容易实现、方便扩展、效率更高。因此在一些热门的项目中用来替代平衡树，它最典型的用途就是作为redis中的zset的基础数据类型。</p>
<p>跳表是在链表的基础上，增加了多级索引，通过索引位置的几个跳转，实现数据的快速定位。</p>
<p><img src="https://static.jiangliuhong.top/images/2024/2/191708313348613.png" alt="191708313348613.png" /></p>
<p>由上图可见，针对存储的数据个数，增加多级索引，查找数据时，按照多级索引，一级一级地以此查找，从而缩短查询的时间，当定位到原始链表后，如果没有查找到对应的值，那么也可以说明这个有序链表中不存在这个元素。</p>
<p><strong>跳表查询的时间复杂度计算：</strong></p>
<p>n/2、n/4、n/8、第 k 级索引结点的个数就是 n/(2^k)</p>
<p>假设索引有 h 级，最高级的索引有 2 个结点。n/(2^h) = 2，从而求得 h = log2(n)-1</p>
<p><img src="https://static.jiangliuhong.top/images/2024/2/191708313595199.png" alt="191708313595199.png" /></p>
<p>举一个例子，跳表在查询的时候，假设索引的高度：logn，每层索引遍历的结点个数：3，假设要走到第 8 个节点。</p>
<p>每层要遍历的元素总共是3个，所以这里的话 log2 8 的话，就是它的时间复杂度。最后的话得出证明出来：时间复杂度为log2n。也就是从最朴素的原始链表的话，它的 O(n) 的时间复杂度降到 log2n 的时间复杂度。这已经是一个很大的改进了。假设是1024的话，你会发现原始链表要查1024次最后得到这个元素，那么这里的话就只需要查（2的10次方是1024次）十次这样一个数量级。</p>
<p><strong>跳表的空间复杂度计算：</strong></p>
<p>假设它的长度为 n，然后按照之前的例子，每两个节点抽一个做成一个索引的话，那么它的一级索引为二分之 n 对吧。最后如下：</p>
<p>原始链表大小为 n，每 2 个结点抽 1 个，每层索引的结点数:  n/2,n/4,n/8,&hellip;&hellip;,8,4,2</p>
<p>原始链表大小为 n，每 3 个结点抽 1 个，每层索引的结点数:  n/3,n/9,n/27,&hellip;&hellip;,9,3,1</p>
<p>空间复杂度是 O(n)</p>
<p><strong>跳表的构成</strong></p>
<p><img src="https://static.jiangliuhong.top/images/2024/2/191708313791809.png" alt="191708313791809.png" /></p>
<p>从图中可以看到， 跳跃表主要由以下部分构成：</p>
<ul>
<li>表头（head）：负责维护跳跃表的节点指针。</li>
<li>跳跃表节点：保存着元素值，以及多个层。</li>
<li>层：保存着指向其他元素的指针。高层的指针越过的元素数量大于等于低层的指针，为了提高查找的效率，程序总是从高层先开始访问，然后随着元素值范围的缩小，慢慢降低层次。</li>
<li>表尾：全部由 NULL 组成，表示跳跃表的末尾。</li>
</ul>
<h3 id="用java实现跳表">
  用java实现跳表
  <a class="anchor" href="#%e7%94%a8java%e5%ae%9e%e7%8e%b0%e8%b7%b3%e8%a1%a8">#</a>
</h3>
<p><a href="https://developer.aliyun.com/article/858584#slide-15">参考链接</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.concurrent.ThreadLocalRandom;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 跳跃表实现
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SkipLists</span><span style="color:#f92672">&lt;</span>Key <span style="color:#66d9ef">extends</span> Comparable<span style="color:#f92672">&lt;</span>Key<span style="color:#f92672">&gt;</span>, Value<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> MAX_LEVEL <span style="color:#f92672">=</span> 32;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> Object BASE_OBJECT <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Object();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> PROBABILITY <span style="color:#f92672">=</span> 50;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">volatile</span> HeaderIndex<span style="color:#f92672">&lt;</span>Key, Value<span style="color:#f92672">&gt;</span> header;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">SkipLists</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">header</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> HeaderIndex(<span style="color:#66d9ef">new</span> Node(<span style="color:#66d9ef">null</span>, BASE_OBJECT, <span style="color:#66d9ef">null</span>), <span style="color:#66d9ef">null</span>, <span style="color:#66d9ef">null</span>, 1);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * 根据key从跳跃表中获取一个值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @param key key
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @return 存在则返回对应的value，不存在则返回null
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Value <span style="color:#a6e22e">get</span>(Key key) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 参数检查</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (key <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalArgumentException();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 找到key对应的前驱节点</span>
</span></span><span style="display:flex;"><span>        Node<span style="color:#f92672">&lt;</span>Key, Value<span style="color:#f92672">&gt;</span> predecessor <span style="color:#f92672">=</span> findPredecessor(key);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 从前驱节点开始遍历查找key对应的节点</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (Node<span style="color:#f92672">&lt;</span>Key, Value<span style="color:#f92672">&gt;</span> next <span style="color:#f92672">=</span> predecessor.<span style="color:#a6e22e">next</span>;;) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (next <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// key与节点的Key比较</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 如果相等就找到了直接返回值</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 如果key大于节点的key，继续向后查找</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 如果key小于节点的key，那么没找到，退出循环</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> cmp <span style="color:#f92672">=</span> key.<span style="color:#a6e22e">compareTo</span>(next.<span style="color:#a6e22e">key</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (cmp <span style="color:#f92672">==</span> 0) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> next.<span style="color:#a6e22e">value</span>;
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (cmp <span style="color:#f92672">&gt;</span> 0) {
</span></span><span style="display:flex;"><span>                next <span style="color:#f92672">=</span> next.<span style="color:#a6e22e">next</span>;
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * 向跳跃表添加一个key-value对
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @param key key
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @param value value
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">put</span>(Key key, Value value) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (key <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> NullPointerException();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        Node<span style="color:#f92672">&lt;</span>Key, Value<span style="color:#f92672">&gt;</span> newNode <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 找到最底层插入节点的前驱节点</span>
</span></span><span style="display:flex;"><span>        Node<span style="color:#f92672">&lt;</span>Key, Value<span style="color:#f92672">&gt;</span> predecessor <span style="color:#f92672">=</span> findPredecessor(key);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 找到索引节点对应的数据节点以后，开始查找插入数据前驱节点</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (Node<span style="color:#f92672">&lt;</span>Key, Value<span style="color:#f92672">&gt;</span> b <span style="color:#f92672">=</span> predecessor, next <span style="color:#f92672">=</span> b.<span style="color:#a6e22e">next</span>;;) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (next <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 如果插入的key大于当前数据节点，那么继续查找下一个</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">int</span> cmp <span style="color:#f92672">=</span> key.<span style="color:#a6e22e">compareTo</span>(next.<span style="color:#a6e22e">key</span>);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (cmp <span style="color:#f92672">&gt;</span> 0) {
</span></span><span style="display:flex;"><span>                    b <span style="color:#f92672">=</span> next;
</span></span><span style="display:flex;"><span>                    next <span style="color:#f92672">=</span> next.<span style="color:#a6e22e">next</span>;
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>                } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (cmp <span style="color:#f92672">==</span> 0) {
</span></span><span style="display:flex;"><span>                    next.<span style="color:#a6e22e">value</span> <span style="color:#f92672">=</span> value;
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 新建节点并更改前驱节点的下一个节点为新节点</span>
</span></span><span style="display:flex;"><span>            newNode <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Node<span style="color:#f92672">&lt;&gt;</span>(key, value, next);
</span></span><span style="display:flex;"><span>            b.<span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> newNode;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 是否要为数据节点添加索引层</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> level <span style="color:#f92672">=</span> randomLevel();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 需要加层</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (level <span style="color:#f92672">&gt;</span> header.<span style="color:#a6e22e">level</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> oldLevel <span style="color:#f92672">=</span> header.<span style="color:#a6e22e">level</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> newLevel <span style="color:#f92672">=</span> level;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 为新节点创建索引节点</span>
</span></span><span style="display:flex;"><span>            Index<span style="color:#f92672">&lt;</span>Key, Value<span style="color:#f92672">&gt;[]</span> newNodeIndexes <span style="color:#f92672">=</span> createNewNodeIndex(newNode, newLevel);
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 为头结点增量补充索引节点,并将头结点的索引节点指向新节点的索引节点</span>
</span></span><span style="display:flex;"><span>            header <span style="color:#f92672">=</span> incrHeaderIdxes(newLevel, newNodeIndexes);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 根据老层更新新节点的数据</span>
</span></span><span style="display:flex;"><span>            updateIndex(key, newNodeIndexes<span style="color:#f92672">[</span>oldLevel<span style="color:#f92672">]</span>, oldLevel, newLevel);
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 如果节点索引层大于1就需要为节点新建索引层</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (level <span style="color:#f92672">&gt;</span> 1) {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 根据新节点索引层新建节点索引</span>
</span></span><span style="display:flex;"><span>                Index<span style="color:#f92672">&lt;</span>Key, Value<span style="color:#f92672">&gt;[]</span> newNodeIndexes <span style="color:#f92672">=</span> createNewNodeIndex(newNode, level);
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 更新索引</span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 在没有新建层时，为新节点新建层传入的新层参数是头索引的层数，因为每次都从头索引开始查找，</span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 需要将头索引直接下降到对应的层后开始修改关系</span>
</span></span><span style="display:flex;"><span>                updateIndex(key, newNodeIndexes<span style="color:#f92672">[</span>level<span style="color:#f92672">]</span>, level, header.<span style="color:#a6e22e">level</span>);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * 根据key删除一个节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * 注意删除节点可能需要减层
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @param key 要删除的关键字
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @return key对应的value值，如果没有找到value就返回null
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Value <span style="color:#a6e22e">delete</span>(Key key) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (key <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> NullPointerException();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        Value val <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 找到最底层插入节点的前驱节点</span>
</span></span><span style="display:flex;"><span>        Node<span style="color:#f92672">&lt;</span>Key, Value<span style="color:#f92672">&gt;</span> predecessor <span style="color:#f92672">=</span> findPredecessor(key);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (Node<span style="color:#f92672">&lt;</span>Key, Value<span style="color:#f92672">&gt;</span> b <span style="color:#f92672">=</span> predecessor, next <span style="color:#f92672">=</span> b.<span style="color:#a6e22e">next</span>;;) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (next <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 如果插入的key大于当前数据节点，那么继续查找下一个</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">int</span> cmp <span style="color:#f92672">=</span> key.<span style="color:#a6e22e">compareTo</span>(next.<span style="color:#a6e22e">key</span>);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (cmp <span style="color:#f92672">&gt;</span> 0) {
</span></span><span style="display:flex;"><span>                    b <span style="color:#f92672">=</span> next;
</span></span><span style="display:flex;"><span>                    next <span style="color:#f92672">=</span> next.<span style="color:#a6e22e">next</span>;
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>                } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (cmp <span style="color:#f92672">&lt;</span> 0) {
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>                } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">// 相等就将节点元素设置为空</span>
</span></span><span style="display:flex;"><span>                    val <span style="color:#f92672">=</span> next.<span style="color:#a6e22e">value</span>;
</span></span><span style="display:flex;"><span>                    next.<span style="color:#a6e22e">value</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 通过查找前驱索引节点删除可能需要删除的索引</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 删除索引的标记信息就是node.value==null</span>
</span></span><span style="display:flex;"><span>        findPredecessor(key);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 删除层</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 如果头索引的右侧索引已经被删除就减层</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (header.<span style="color:#a6e22e">right</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> header.<span style="color:#a6e22e">level</span> <span style="color:#f92672">&gt;</span> 1) {
</span></span><span style="display:flex;"><span>            header <span style="color:#f92672">=</span> (HeaderIndex<span style="color:#f92672">&lt;</span>Key, Value<span style="color:#f92672">&gt;</span>) header.<span style="color:#a6e22e">down</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> val;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * 查找key对应的前驱索引
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @param key key
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @return 前驱索引
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> Index<span style="color:#f92672">&lt;</span>Key, Value<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">findIndex</span>(Key key) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (Index<span style="color:#f92672">&lt;</span>Key, Value<span style="color:#f92672">&gt;</span> cur <span style="color:#f92672">=</span> header, right <span style="color:#f92672">=</span> cur.<span style="color:#a6e22e">right</span>, down;;) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 如果索引的右侧不为空</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 用搜索的key对数据节点的key进行比较</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 如果搜索的key大于索引节点的key，那么继续向右进行搜索</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (right <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span>) {
</span></span><span style="display:flex;"><span>                Node<span style="color:#f92672">&lt;</span>Key, Value<span style="color:#f92672">&gt;</span> n <span style="color:#f92672">=</span> right.<span style="color:#a6e22e">node</span>;
</span></span><span style="display:flex;"><span>                Key k <span style="color:#f92672">=</span> n.<span style="color:#a6e22e">key</span>;
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// value为空代表节点的值已经被删除</span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 删除节点对应的索引</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (n.<span style="color:#a6e22e">value</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span>) {
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">// 将当前所有的右侧索引更新为右侧的右侧</span>
</span></span><span style="display:flex;"><span>                    cur.<span style="color:#a6e22e">right</span> <span style="color:#f92672">=</span> right.<span style="color:#a6e22e">right</span>;
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">// 更新right索引变量为当前索引的右侧</span>
</span></span><span style="display:flex;"><span>                    right <span style="color:#f92672">=</span> cur.<span style="color:#a6e22e">right</span>;
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 如果搜索的key大于右侧节点指向的key，那么继续向右查找</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (key.<span style="color:#a6e22e">compareTo</span>(k) <span style="color:#f92672">&gt;</span> 0) {
</span></span><span style="display:flex;"><span>                    cur <span style="color:#f92672">=</span> right;
</span></span><span style="display:flex;"><span>                    right <span style="color:#f92672">=</span> right.<span style="color:#a6e22e">right</span>;
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 如果索引节点的右侧节点大于key，那么向下放索引查找</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> ((down <span style="color:#f92672">=</span> cur.<span style="color:#a6e22e">down</span>) <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 将当前节点指向下方索引节点</span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 右侧节点指针指向下方索引的右侧</span>
</span></span><span style="display:flex;"><span>                cur <span style="color:#f92672">=</span> down;
</span></span><span style="display:flex;"><span>                right <span style="color:#f92672">=</span> down.<span style="color:#a6e22e">right</span>;
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> cur;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * 查找key对应的前驱节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @param key key
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @return 前驱节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> Node<span style="color:#f92672">&lt;</span>Key, Value<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">findPredecessor</span>(Key key) {
</span></span><span style="display:flex;"><span>        Index<span style="color:#f92672">&lt;</span>Key, Value<span style="color:#f92672">&gt;</span> index <span style="color:#f92672">=</span> findIndex(key);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> index.<span style="color:#a6e22e">node</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * 更新老层的索引
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @param key 关键字
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @param newNodeOldIdx 新节点索引
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @param oldLevel 老层数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @param newLevel 新层数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">updateIndex</span>(Key key, Index<span style="color:#f92672">&lt;</span>Key, Value<span style="color:#f92672">&gt;</span> newNodeOldIdx, <span style="color:#66d9ef">int</span> oldLevel, <span style="color:#66d9ef">int</span> newLevel) {
</span></span><span style="display:flex;"><span>        Index<span style="color:#f92672">&lt;</span>Key, Value<span style="color:#f92672">&gt;</span> newNodeIdx <span style="color:#f92672">=</span> newNodeOldIdx;
</span></span><span style="display:flex;"><span>        Index<span style="color:#f92672">&lt;</span>Key, Value<span style="color:#f92672">&gt;</span> precursorIdx <span style="color:#f92672">=</span> header;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 跳过新索引层，因为已经做了关联</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> oldLevel <span style="color:#f92672">+</span> 1; i <span style="color:#f92672">&lt;=</span> newLevel; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            precursorIdx <span style="color:#f92672">=</span> precursorIdx.<span style="color:#a6e22e">down</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        Index<span style="color:#f92672">&lt;</span>Key, Value<span style="color:#f92672">&gt;</span> right <span style="color:#f92672">=</span> precursorIdx.<span style="color:#a6e22e">right</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 找到对应的层之后，我们开始向右继续查找前驱索引节点</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (<span style="color:#66d9ef">true</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (right <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> right.<span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">value</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">int</span> cmp <span style="color:#f92672">=</span> key.<span style="color:#a6e22e">compareTo</span>(right.<span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">key</span>);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (cmp <span style="color:#f92672">&gt;</span> 0) {
</span></span><span style="display:flex;"><span>                    precursorIdx <span style="color:#f92672">=</span> right;
</span></span><span style="display:flex;"><span>                    right <span style="color:#f92672">=</span> right.<span style="color:#a6e22e">right</span>;
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 找到需要更新的索引之后，重建索引</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 前驱索引节点的右侧设置新的索引</span>
</span></span><span style="display:flex;"><span>            precursorIdx.<span style="color:#a6e22e">right</span> <span style="color:#f92672">=</span> newNodeIdx;
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 新索引有右侧设置为老索引的右侧节点</span>
</span></span><span style="display:flex;"><span>            newNodeIdx.<span style="color:#a6e22e">right</span> <span style="color:#f92672">=</span> right;
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 新节点索引向下</span>
</span></span><span style="display:flex;"><span>            newNodeIdx <span style="color:#f92672">=</span> newNodeIdx.<span style="color:#a6e22e">down</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 老索引向下</span>
</span></span><span style="display:flex;"><span>            precursorIdx <span style="color:#f92672">=</span> precursorIdx.<span style="color:#a6e22e">down</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (precursorIdx <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * 随机生成节点的层，但是不超过32
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @return 新节点层数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">randomLevel</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> level <span style="color:#f92672">=</span> 1;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> rnd <span style="color:#f92672">=</span> ThreadLocalRandom.<span style="color:#a6e22e">current</span>().<span style="color:#a6e22e">nextInt</span>(1, 101);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (rnd <span style="color:#f92672">&gt;</span> PROBABILITY <span style="color:#f92672">&amp;&amp;</span> level <span style="color:#f92672">&lt;=</span> MAX_LEVEL) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 根据随机数来生成索引层数</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">++</span>level;
</span></span><span style="display:flex;"><span>            rnd <span style="color:#f92672">=</span> ThreadLocalRandom.<span style="color:#a6e22e">current</span>().<span style="color:#a6e22e">nextInt</span>(1, 101);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> level;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * 为头结点补充索引层级
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @param newLevel 新层数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @param newNodeIdxes 新节点索引数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @return 新的头结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> HeaderIndex<span style="color:#f92672">&lt;</span>Key, Value<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">incrHeaderIdxes</span>(<span style="color:#66d9ef">int</span> newLevel, Index<span style="color:#f92672">&lt;</span>Key, Value<span style="color:#f92672">&gt;[]</span> newNodeIdxes) {
</span></span><span style="display:flex;"><span>        HeaderIndex<span style="color:#f92672">&lt;</span>Key, Value<span style="color:#f92672">&gt;</span> newHeader <span style="color:#f92672">=</span> header;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> header.<span style="color:#a6e22e">level</span> <span style="color:#f92672">+</span> 1; i <span style="color:#f92672">&lt;=</span> newLevel; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            newHeader <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> HeaderIndex<span style="color:#f92672">&lt;&gt;</span>(header.<span style="color:#a6e22e">node</span>, newHeader, newNodeIdxes<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span>, i);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> newHeader;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * 为新节点创建索引节点，并建立向下的索引关系
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @param newNode 新节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @param newLevel 层数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @return 新节点的索引节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> Index<span style="color:#f92672">&lt;</span>Key,Value<span style="color:#f92672">&gt;[]</span> <span style="color:#a6e22e">createNewNodeIndex</span>(Node<span style="color:#f92672">&lt;</span>Key,Value<span style="color:#f92672">&gt;</span> newNode, <span style="color:#66d9ef">int</span> newLevel) {
</span></span><span style="display:flex;"><span>        Index<span style="color:#f92672">&lt;</span>Key,Value<span style="color:#f92672">&gt;[]</span> newNodeIdxes <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Index<span style="color:#f92672">[</span>newLevel <span style="color:#f92672">+</span> 1<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>        Index<span style="color:#f92672">&lt;</span>Key,Value<span style="color:#f92672">&gt;</span> newIndex <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 1; i <span style="color:#f92672">&lt;=</span> newLevel; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            newIndex <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Index<span style="color:#f92672">&lt;&gt;</span>(newNode, newIndex, <span style="color:#66d9ef">null</span>);
</span></span><span style="display:flex;"><span>            newNodeIdxes<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> newIndex;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> newNodeIdxes;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * 数据节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Node</span><span style="color:#f92672">&lt;</span>Key, Value<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * 键
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">final</span> Key key;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * 值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">volatile</span> Value value;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * 链表指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">volatile</span> Node<span style="color:#f92672">&lt;</span>Key, Value<span style="color:#f92672">&gt;</span> next;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">Node</span>(Key key, Value value, Node<span style="color:#f92672">&lt;</span>Key, Value<span style="color:#f92672">&gt;</span> next) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">key</span> <span style="color:#f92672">=</span> key;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">value</span> <span style="color:#f92672">=</span> value;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> next;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * 索引
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Index</span><span style="color:#f92672">&lt;</span>K,V<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">final</span> Node<span style="color:#f92672">&lt;</span>K,V<span style="color:#f92672">&gt;</span> node;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">volatile</span> Index<span style="color:#f92672">&lt;</span>K,V<span style="color:#f92672">&gt;</span> right;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">volatile</span> Index<span style="color:#f92672">&lt;</span>K,V<span style="color:#f92672">&gt;</span> down;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">Index</span>(Node<span style="color:#f92672">&lt;</span>K,V<span style="color:#f92672">&gt;</span> node, Index<span style="color:#f92672">&lt;</span>K,V<span style="color:#f92672">&gt;</span> down, Index<span style="color:#f92672">&lt;</span>K,V<span style="color:#f92672">&gt;</span> right) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">node</span> <span style="color:#f92672">=</span> node;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">right</span> <span style="color:#f92672">=</span> right;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">down</span> <span style="color:#f92672">=</span> down;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * 头
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">HeaderIndex</span><span style="color:#f92672">&lt;</span>K,V<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">extends</span> Index<span style="color:#f92672">&lt;</span>K,V<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> level;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">HeaderIndex</span>(Node<span style="color:#f92672">&lt;</span>K,V<span style="color:#f92672">&gt;</span> node, Index<span style="color:#f92672">&lt;</span>K,V<span style="color:#f92672">&gt;</span> down, Index<span style="color:#f92672">&lt;</span>K,V<span style="color:#f92672">&gt;</span> right, <span style="color:#66d9ef">int</span> level) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">super</span>(node, down, right);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">level</span> <span style="color:#f92672">=</span> level;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="redis跳表的实现">
  redis跳表的实现
  <a class="anchor" href="#redis%e8%b7%b3%e8%a1%a8%e7%9a%84%e5%ae%9e%e7%8e%b0">#</a>
</h3>
<p>Redis 的跳跃表由 redis.h/zskiplistNode 和 redis.h/zskiplist 两个结构定义， 其中 zskiplistNode 结构用于表示跳跃表节点， 而 zskiplist 结构则用于保存跳跃表节点的相关信息， 比如节点的数量， 以及指向表头节点和表尾节点的指针， 等等。</p>
<p><img src="https://static.jiangliuhong.top/images/2024/2/191708314270469.png" alt="191708314270469.png" /></p>
<p>上图展示了一个跳跃表示例，位于图片最左边的示 zskiplist 结构，该结构包含以下属性：</p>
<ul>
<li>header ：指向跳跃表的表头节点。</li>
<li>tail ：指向跳跃表的表尾节点。</li>
<li>level ：记录目前跳跃表内，层数最大的那个节点的层数（表头节点的层数不计算在内）。</li>
<li>length ：记录跳跃表的长度，也即是，跳跃表目前包含节点的数量（表头节点不计算在内）。</li>
</ul>
<p>位于 zskiplist 结构右方的是四个 zskiplistNode 结构， 该结构包含以下属性：</p>
<ul>
<li>层（level）：节点中用 L1 、 L2 、 L3 等字样标记节点的各个层， L1 代表第一层， L2 代表第二层，以此类推。每个层都带有两个属性：前进指针和跨度。前进指针用于访问位于表尾方向的其他节点，而跨度则记录了前进指针所指向节点和当前节点的距离。在上面的图片中，连线上带有数字的箭头就代表前进指针，而那个数字就是跨度。当程序从表头向表尾进行遍历时，访问会沿着层的前进指针进行。</li>
<li>后退（backward）指针：节点中用 BW 字样标记节点的后退指针，它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用。</li>
<li>分值（score）：各个节点中的 1.0 、 2.0 和 3.0 是节点所保存的分值。在跳跃表中，节点按各自所保存的分值从小到大排列。</li>
<li>成员对象（obj）：各个节点中的 o1 、 o2 和 o3 是节点所保存的成员对象。</li>
</ul>
<p>参考链接：<a href="https://juejin.cn/post/6893072817206591496">https://juejin.cn/post/6893072817206591496</a></p>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#二叉树">二叉树</a>
      <ul>
        <li><a href="#红黑树">红黑树</a></li>
        <li></li>
      </ul>
    </li>
    <li><a href="#压缩列表ziplist">压缩列表(ziplist)</a></li>
    <li><a href="#跳跃表zskiplist">跳跃表(zSkiplist)</a>
      <ul>
        <li><a href="#用java实现跳表">用java实现跳表</a></li>
        <li><a href="#redis跳表的实现">redis跳表的实现</a></li>
      </ul>
    </li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












