<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Docs on 复习吧</title>
    <link>http://localhost:1313/docs/</link>
    <description>Recent content in Docs on 复习吧</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 21 Feb 2024 10:48:17 +0800</lastBuildDate>
    <atom:link href="http://localhost:1313/docs/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>消息中间件</title>
      <link>http://localhost:1313/docs/middleware/messagequeue/</link>
      <pubDate>Tue, 20 Feb 2024 11:53:59 +0800</pubDate>
      <guid>http://localhost:1313/docs/middleware/messagequeue/</guid>
      <description>&lt;h1 id=&#34;消息中间件&#34;&gt;&#xA;  消息中间件&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b6%88%e6%81%af%e4%b8%ad%e9%97%b4%e4%bb%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;消息队列设计精要&#34;&gt;&#xA;  消息队列设计精要&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97%e8%ae%be%e8%ae%a1%e7%b2%be%e8%a6%81&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;使用消息队列的常见场景主要有业务解耦、最终一致性、错峰流控等。&lt;/p&gt;&#xA;&lt;p&gt;解耦：消息队列要解决的本质问题，各个组件之间，不再显示依赖，只需要做到消息发送成功。&lt;/p&gt;&#xA;&lt;p&gt;最终一致性：使得所有系统结果保持一致，要么都成功，要么都失败。在使用消息队列处理最终一致性问题时，往往是对失败的消息进行重试操作，直到成功为止（这里需要要求幂等性）。同时对于始终不成功的消息，也需要增加补偿操作，进一步保证最终一致性。&lt;/p&gt;&#xA;&lt;p&gt;错峰流控：对于一些并发较大的操作，如果一同进行，可能导致应用无法承受而宕机，加入消息队列后，可以在消费者处进行限制，按照消费者能力对消息进行处理，同时由于消息队列集群消费的特性，也可以根据消息的实际情况，按需增删消费者实例。&lt;/p&gt;&#xA;&lt;p&gt;对于一个消息队列而言，它应该具有的功能有：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/e93c3107.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&#xA;&lt;p&gt;参考链接：&lt;a href=&#34;https://tech.meituan.com/2016/07/01/mq-design.html&#34;&gt;https://tech.meituan.com/2016/07/01/mq-design.html&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;为什么使用mq&#34;&gt;&#xA;  为什么使用mq&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%ba%e4%bb%80%e4%b9%88%e4%bd%bf%e7%94%a8mq&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h2 id=&#34;rocketmq&#34;&gt;&#xA;  rocketmq&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#rocketmq&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;</description>
    </item>
    <item>
      <title>数据结构</title>
      <link>http://localhost:1313/docs/arithmetic/data/</link>
      <pubDate>Sun, 18 Feb 2024 11:53:59 +0800</pubDate>
      <guid>http://localhost:1313/docs/arithmetic/data/</guid>
      <description>&lt;h1 id=&#34;数据结构&#34;&gt;&#xA;  数据结构&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;二叉树&#34;&gt;&#xA;  二叉树&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%8c%e5%8f%89%e6%a0%91&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;红黑树&#34;&gt;&#xA;  红黑树&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ba%a2%e9%bb%91%e6%a0%91&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h3 id=&#34;&#34;&gt;&#xA;  &#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h2 id=&#34;压缩列表ziplist&#34;&gt;&#xA;  压缩列表(ziplist)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8e%8b%e7%bc%a9%e5%88%97%e8%a1%a8ziplist&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;ziplist是一个经过特殊编码的双向链表，它的设计目标是节省内存。它可以存储字符串或者整数。其中整数是按二进制进行编码的，而不是字符串序列。&lt;/p&gt;&#xA;&lt;p&gt;它能以O(1)的时间复杂度在列表的两端进行push和pop操作。但是由于每个操作都 u 要对ziplist所使用的内存进行重新分配，所以实际操作的复杂度与ziplist占用的内存大小有关。&lt;/p&gt;&#xA;&lt;p&gt;在redis中，有序集合、散列和列表都直接或间接使用了压缩列表。当有序集合或散列的元素个数较少，并且元素都是短字符串时，redis便会使用压缩列表作为底层数据存储。redis的列表使用的快速链表数据结构进行存储，而快速链表就是双向链表与压缩列表的组合。&lt;/p&gt;&#xA;&lt;p&gt;总的来说，ziplist有如下特性：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;本质上是一个字节数组&lt;/li&gt;&#xA;&lt;li&gt;是redis为了节约内存而设计的一种线性结构&lt;/li&gt;&#xA;&lt;li&gt;可以包含多个元素，每个元素可以是一个字节数组或一个整数&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;在redis中，压缩列表主要由 5 部分组成：&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;属性&lt;/th&gt;&#xA;          &lt;th&gt;类型&lt;/th&gt;&#xA;          &lt;th&gt;长度&lt;/th&gt;&#xA;          &lt;th&gt;用途&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;zlbytes&lt;/td&gt;&#xA;          &lt;td&gt;unit32_t&lt;/td&gt;&#xA;          &lt;td&gt;4字节&lt;/td&gt;&#xA;          &lt;td&gt;记录整个压缩列表占用的内存字节数：在对压缩列表进行内存重分配，或者计算 zlend 的位置时使用。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;zltail&lt;/td&gt;&#xA;          &lt;td&gt;unit32_t&lt;/td&gt;&#xA;          &lt;td&gt;4字节&lt;/td&gt;&#xA;          &lt;td&gt;记录压缩列表表尾节点距离压缩列表的起始地址有多少字节：通过这个偏移量，程序无需遍历整个压缩列表就可以确定表尾节点的地址。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;zllen&lt;/td&gt;&#xA;          &lt;td&gt;unit16_t&lt;/td&gt;&#xA;          &lt;td&gt;2字节&lt;/td&gt;&#xA;          &lt;td&gt;记录了压缩列表包含的节点数量，当这个属性的值小于 UINT16_MAX（65535）时，这个属性的值就是压缩列表包含节点的数量；当这个值等于 UINT16_MAX 时，节点的真实数量需要遍历整个压缩列表才能计算得出。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;entry&lt;/td&gt;&#xA;          &lt;td&gt;列表节点&lt;/td&gt;&#xA;          &lt;td&gt;不定&lt;/td&gt;&#xA;          &lt;td&gt;压缩列表包含的各个节点&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;zlend&lt;/td&gt;&#xA;          &lt;td&gt;unit8_t&lt;/td&gt;&#xA;          &lt;td&gt;1字节&lt;/td&gt;&#xA;          &lt;td&gt;特殊值 0xFF（十进制 255），用于标记压缩列表的末端。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://static.jiangliuhong.top/images/2024/2/191708309348283.png&#34; alt=&#34;191708309348283.png&#34; /&gt;&lt;/p&gt;&#xA;&lt;p&gt;如上图所示，这是一个包含三个节点的压缩列表的示例：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;zlbytes 属性的值为 0x50（十进制 80），表示压缩列表的总长为 80 字节。&lt;/li&gt;&#xA;&lt;li&gt;zltail 属性的值为 0x3c（十进制 60），这表示如果我们有一个指向压缩列表起始地址的指针 p，那么只要用指针 p 加上偏移量 60，就可以计算出表尾节点 entry3 的地址。&lt;/li&gt;&#xA;&lt;li&gt;zllen 属性的值为 0x3（十进制 3），表示压缩列表包含三个节点。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;对于压缩列表而言，每个entry的数据结构又包含三部分，分别是：&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
