+++
title = '事务'
date = 2023-12-04T12:44:59+08:00
draft = false
+++

# 事务

## 隔离级别

MySQL 事务隔离级别分为 4 个：
- READ UNCOMMITTED：读未提交。
- READ COMMITTED：读已提交。
- REPEATABLE READ：可重复读。
- SERIALIZABLE：序列化。

### READ UNCOMMITTED

读取未提交的数据，该隔离级别的事务可以看到其他事务下未提交的数据。

同时由于未提交的数据可能会发生回滚，因此我们把该级别读取到的数据称之为脏数据，把这个问题称之为脏读。

### READ COMMITTED

读取已提交的数据，所有的数据都是已提交的，所以不会出现脏读的情况，但由于在不同事务中可以读取到其他事务已提交的数据，所以在不同的sql中，可能出现读取的数据不一致的情况，这种情况叫做不可重复读。

### REPEATABLE READ

可重复度，这是 MySQL 默认的事务隔离级别，该隔离级别可以解决 READ COMMITED 所产生的不可重复读问题，但由于同一个事务的不同时间点，使用同一个 SQL 查询数据时，可能出现不同的结果，这种情况叫做幻读。

一个典型的例子：

执行sql：

```sql
select id,name from user
```

第一次执行结果：

id|name
---|---
1|test1


第一次执行结果：

id|name
---|---
1|test1
2|test2

其中，id 为 2 记录则是一个幻读的行

### SERIALIZABLE

序列化，这是 MySQL 事务隔离级别中最高的级别，它会强制事务排序，使之不会发生冲突，从而解决了脏读、不可重复读和幻读问题，但因为执行效率低，所以真正使用的场景并不多。


### 幻读和不可重复读区别

幻读和不可重复读的侧重点不同的：
- 不可重复读侧重于数据修改，两次读取到的同一行数据不一样。
- 幻读侧重于添加或删除，两次查询返回的数据行数不同。

### 不同隔离级别总结

隔离级别|脏读|不可重复读|幻读
---|---|---|---
READ UNCOMMITTED|Y|Y|Y
READ COMMITTED|N|Y|Y
REPEATABLE READ|N|N|Y
SERIALIZABLE｜N|N|N

### 如何选择隔离级别

## 并发事务问题
